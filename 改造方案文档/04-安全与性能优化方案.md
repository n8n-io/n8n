# n8n å¤šç§Ÿæˆ·æ¶æ„ - å®‰å…¨ä¸æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ

> **é…å¥—æ–‡æ¡£ï¼š** 01-æ¶æ„åº•å±‚æ”¹é€ æ–¹æ¡ˆ.md (v3.0)
> **ç‰ˆæœ¬ï¼š** v1.0
> **æ—¥æœŸï¼š** 2025-11-07
> **çŠ¶æ€ï¼š** âš ï¸ P0çº§åˆ« - å¿…é¡»å®æ–½

---

## ğŸ“‹ ä¸€ã€å®‰å…¨é˜²æŠ¤ä½“ç³»

### 1.1 å¹¶å‘å®‰å…¨ - ä½™é¢æ‰£è´¹é˜²é€æ”¯ï¼ˆP0 - å…³é”®ï¼‰

#### é—®é¢˜æè¿°

å½“å‰æ–¹æ¡ˆä¸­ï¼Œé«˜å¹¶å‘åœºæ™¯ä¸‹å¯èƒ½å‡ºç°ä½™é¢é€æ”¯ï¼š

```typescript
// âŒ æœ‰é—®é¢˜çš„ä»£ç 
async recordUsageAndCharge(params: UsageParams) {
  await this.projectRepository.manager.transaction(async (trx) => {
    // è¯»å–ä½™é¢
    const workspace = await trx.findOne(Project, { where: { id } });

    // æ£€æŸ¥ä½™é¢
    if (workspace.balanceCny < cost) {
      throw new InsufficientBalanceError();
    }

    // æ‰£é™¤ä½™é¢ - è¿™é‡Œå­˜åœ¨å¹¶å‘é—®é¢˜ï¼
    await trx.decrement(Project, { id }, 'balanceCny', cost);
  });
}

// å¹¶å‘åœºæ™¯:
// çº¿ç¨‹A: è¯»å–ä½™é¢ Â¥10 â†’ æ£€æŸ¥é€šè¿‡ â†’ å‡†å¤‡æ‰£ Â¥8
// çº¿ç¨‹B: è¯»å–ä½™é¢ Â¥10 â†’ æ£€æŸ¥é€šè¿‡ â†’ å‡†å¤‡æ‰£ Â¥8
// ç»“æœ: ä½™é¢å˜æˆ -Â¥6 (é€æ”¯äº†!)
```

#### è§£å†³æ–¹æ¡ˆï¼šæ‚²è§‚é”

```typescript
// âœ… æ­£ç¡®çš„ä»£ç  - ä½¿ç”¨æ‚²è§‚é”
@Service()
export class BillingService {
  constructor(
    @InjectRepository(Project)
    private readonly projectRepository: Repository<Project>,
    @InjectRepository(UsageRecord)
    private readonly usageRecordRepository: Repository<UsageRecord>,
  ) {}

  /**
   * è®°å½•ä½¿ç”¨é‡å¹¶æ‰£è´¹ï¼ˆå¸¦æ‚²è§‚é”ï¼‰
   */
  async recordUsageAndCharge(params: {
    workspaceId: string;
    userId: string;
    serviceKey: string;
    serviceType: string;
    tokensUsed?: number;
    callsCount?: number;
    amountCny: number;
    metadata?: Record<string, any>;
  }): Promise<UsageRecord> {
    const { workspaceId, amountCny } = params;

    return await this.projectRepository.manager.transaction(async (trx) => {
      // ğŸ”’ æ­¥éª¤1: ä½¿ç”¨æ‚²è§‚å†™é”é”å®šå·¥ä½œç©ºé—´è®°å½•
      const workspace = await trx.findOne(Project, {
        where: { id: workspaceId },
        lock: { mode: 'pessimistic_write' }, // âœ… æ‚²è§‚é”
      });

      if (!workspace) {
        throw new WorkspaceNotFoundError();
      }

      // æ­¥éª¤2: æ£€æŸ¥ä½™é¢
      if (workspace.balanceCny < amountCny) {
        throw new InsufficientBalanceError(
          `Workspace balance: Â¥${workspace.balanceCny}, required: Â¥${amountCny}`,
        );
      }

      // æ­¥éª¤3: æ‰£é™¤ä½™é¢ï¼ˆåœ¨é”çš„ä¿æŠ¤ä¸‹ï¼Œå®‰å…¨æ‰§è¡Œï¼‰
      workspace.balanceCny -= amountCny;
      await trx.save(workspace);

      // æ­¥éª¤4: åˆ›å»ºä½¿ç”¨è®°å½•
      const usageRecord = this.usageRecordRepository.create({
        workspaceId,
        userId: params.userId,
        serviceKey: params.serviceKey,
        serviceType: params.serviceType,
        tokensUsed: params.tokensUsed,
        callsCount: params.callsCount || 1,
        amountCny,
        metadata: params.metadata,
      });

      await trx.save(usageRecord);

      // æ­¥éª¤5: æ£€æŸ¥æ˜¯å¦ä½äºé˜ˆå€¼ï¼Œå‘é€å‘Šè­¦
      if (workspace.balanceCny < workspace.lowBalanceThresholdCny) {
        await this.sendLowBalanceAlert(workspace);
      }

      return usageRecord;
    });
  }

  /**
   * ä½ä½™é¢å‘Šè­¦
   */
  private async sendLowBalanceAlert(workspace: Project): Promise<void> {
    // å‘é€é‚®ä»¶/çŸ­ä¿¡/ç³»ç»Ÿé€šçŸ¥
    this.logger.warn('Low balance detected', {
      workspaceId: workspace.id,
      balance: workspace.balanceCny,
      threshold: workspace.lowBalanceThresholdCny,
    });

    // TODO: é›†æˆé‚®ä»¶æœåŠ¡/æ¶ˆæ¯é˜Ÿåˆ—
  }
}
```

#### æ€§èƒ½å½±å“

- **æ‚²è§‚é”å¼€é”€ï¼š** å•æ¬¡æ‰£è´¹å¢åŠ çº¦ 5-10ms
- **å¹¶å‘å®‰å…¨ï¼š** å®Œå…¨æ¶ˆé™¤ä½™é¢é€æ”¯é£é™©
- **é€‚ç”¨åœºæ™¯ï¼š** é«˜å¹¶å‘æ‰£è´¹åœºæ™¯ï¼ˆAIæœåŠ¡è°ƒç”¨ï¼‰

---

### 1.2 APIé™æµé˜²æŠ¤ï¼ˆP0 - å…³é”®ï¼‰

#### é—®é¢˜æè¿°

æ— é™æµä¿æŠ¤å¯èƒ½å¯¼è‡´ï¼š
1. æ¶æ„ç”¨æˆ·åˆ·æ¥å£ï¼Œæ¶ˆè€—å¤§é‡èµ„æº
2. å¹³å°æœåŠ¡è´¹ç”¨å¤±æ§ï¼ˆAIè°ƒç”¨æŒ‰é‡è®¡è´¹ï¼‰
3. ç³»ç»Ÿè¿‡è½½å´©æºƒ

#### è§£å†³æ–¹æ¡ˆï¼šRedis + æ»‘åŠ¨çª—å£é™æµ

**é™æµä¸­é—´ä»¶å®ç°ï¼š**

```typescript
// packages/cli/src/middlewares/rate-limit.middleware.ts

import { Service } from '@n8n/di';
import type { RequestHandler } from 'express';
import { Redis } from 'ioredis';

interface RateLimitOptions {
  limit: number;           // é™åˆ¶æ¬¡æ•°
  window: number;          // æ—¶é—´çª—å£ï¼ˆç§’ï¼‰
  keyPrefix?: string;      // Redisé”®å‰ç¼€
  skipSuccessfulRequests?: boolean; // æ˜¯å¦è·³è¿‡æˆåŠŸè¯·æ±‚
}

@Service()
export class RateLimitService {
  constructor(private readonly redis: Redis) {}

  /**
   * åˆ›å»ºé™æµä¸­é—´ä»¶
   */
  createMiddleware(options: RateLimitOptions): RequestHandler {
    const { limit, window, keyPrefix = 'ratelimit' } = options;

    return async (req: AuthenticatedRequest, res, next) => {
      const workspaceId = req.workspaceContext?.workspaceId;
      const userId = req.user?.id;

      if (!workspaceId || !userId) {
        // æœªè®¤è¯è¯·æ±‚ï¼Œä½¿ç”¨IPé™æµ
        return this.checkRateLimit(
          `${keyPrefix}:ip:${req.ip}`,
          limit,
          window,
          req,
          res,
          next,
        );
      }

      // å·²è®¤è¯è¯·æ±‚ï¼Œä½¿ç”¨å·¥ä½œç©ºé—´é™æµ
      return this.checkRateLimit(
        `${keyPrefix}:workspace:${workspaceId}`,
        limit,
        window,
        req,
        res,
        next,
      );
    };
  }

  /**
   * æ£€æŸ¥é™æµ
   */
  private async checkRateLimit(
    key: string,
    limit: number,
    window: number,
    req: any,
    res: any,
    next: any,
  ): Promise<void> {
    try {
      const now = Date.now();
      const windowStart = now - window * 1000;

      // ä½¿ç”¨Redis Sorted Setå®ç°æ»‘åŠ¨çª—å£
      const multi = this.redis.multi();

      // 1. ç§»é™¤çª—å£å¤–çš„è®°å½•
      multi.zremrangebyscore(key, 0, windowStart);

      // 2. ç»Ÿè®¡çª—å£å†…çš„è¯·æ±‚æ•°
      multi.zcard(key);

      // 3. æ·»åŠ å½“å‰è¯·æ±‚
      multi.zadd(key, now, `${now}-${Math.random()}`);

      // 4. è®¾ç½®è¿‡æœŸæ—¶é—´
      multi.expire(key, window);

      const results = await multi.exec();
      const count = results?.[1]?.[1] as number;

      // è®¾ç½®å“åº”å¤´
      res.setHeader('X-RateLimit-Limit', limit);
      res.setHeader('X-RateLimit-Remaining', Math.max(0, limit - count));
      res.setHeader('X-RateLimit-Reset', Math.ceil((now + window * 1000) / 1000));

      if (count >= limit) {
        return res.status(429).json({
          error: 'Too Many Requests',
          message: `Rate limit exceeded. Limit: ${limit} requests per ${window} seconds`,
          retryAfter: window,
        });
      }

      next();
    } catch (error) {
      // é™æµæœåŠ¡å¼‚å¸¸ï¼Œé™çº§å¤„ç†ï¼ˆå…è®¸è¯·æ±‚é€šè¿‡ï¼‰
      this.logger.error('Rate limit check failed', { error });
      next();
    }
  }
}
```

**ä½¿ç”¨ç¤ºä¾‹ï¼š**

```typescript
// packages/cli/src/controllers/platform-rag.controller.ts

import { Post, RestController } from '@/decorators';
import { RateLimitService } from '@/middlewares/rate-limit.middleware';

@RestController('/platform-rag')
export class PlatformRagController {
  constructor(
    private readonly platformRagService: PlatformRagService,
    private readonly rateLimitService: RateLimitService,
  ) {}

  /**
   * è°ƒç”¨å¹³å°RAGæœåŠ¡ï¼ˆé™æµï¼šæ¯åˆ†é’Ÿ100æ¬¡ï¼‰
   */
  @Post('/query')
  @UseMiddleware(rateLimitService.createMiddleware({ limit: 100, window: 60 }))
  async queryRag(req: AuthenticatedRequest) {
    const { serviceKey, query } = req.body;
    return await this.platformRagService.query(serviceKey, query);
  }
}
```

#### é™æµç­–ç•¥é…ç½®

| æ¥å£ç±»å‹ | é™æµè§„åˆ™ | è¯´æ˜ |
|---------|---------|------|
| **å¹³å°æœåŠ¡è°ƒç”¨** | 100æ¬¡/åˆ†é’Ÿ/å·¥ä½œç©ºé—´ | é˜²æ­¢AIè´¹ç”¨å¤±æ§ |
| **å·¥ä½œæµæ‰§è¡Œ** | 1000æ¬¡/å°æ—¶/å·¥ä½œç©ºé—´ | é˜²æ­¢æ¶æ„å¾ªç¯æ‰§è¡Œ |
| **ç™»å½•æ¥å£** | 5æ¬¡/åˆ†é’Ÿ/IP | é˜²æ­¢æš´åŠ›ç ´è§£ |
| **æ³¨å†Œæ¥å£** | 3æ¬¡/å°æ—¶/IP | é˜²æ­¢æ‰¹é‡æ³¨å†Œ |
| **å……å€¼æ¥å£** | 10æ¬¡/å°æ—¶/å·¥ä½œç©ºé—´ | é˜²æ­¢å¼‚å¸¸å……å€¼ |

---

### 1.3 XSS & CSRF é˜²æŠ¤ï¼ˆP1ï¼‰

#### XSSé˜²æŠ¤

**å‰ç«¯è‡ªåŠ¨è½¬ä¹‰ï¼ˆVueå·²å†…ç½®ï¼‰ï¼š**
```vue
<!-- âœ… Vueè‡ªåŠ¨è½¬ä¹‰ -->
<div>{{ userInput }}</div>

<!-- âŒ å±é™©ç”¨æ³•ï¼Œå¿…é¡»é¿å… -->
<div v-html="userInput"></div>
```

**CSPå¤´éƒ¨é…ç½®ï¼š**
```typescript
// packages/cli/src/middlewares/security-headers.middleware.ts

@Service()
export class SecurityHeadersMiddleware {
  handle(): RequestHandler {
    return (req, res, next) => {
      // Content Security Policy
      res.setHeader(
        'Content-Security-Policy',
        "default-src 'self'; " +
        "script-src 'self' 'unsafe-inline' 'unsafe-eval'; " + // Vite devéœ€è¦
        "style-src 'self' 'unsafe-inline'; " +
        "img-src 'self' data: https:; " +
        "font-src 'self' data:; " +
        "connect-src 'self' ws: wss:;",
      );

      // X-Frame-Options: é˜²æ­¢ç‚¹å‡»åŠ«æŒ
      res.setHeader('X-Frame-Options', 'SAMEORIGIN');

      // X-Content-Type-Options: é˜²æ­¢MIMEå—…æ¢
      res.setHeader('X-Content-Type-Options', 'nosniff');

      // X-XSS-Protection: æµè§ˆå™¨XSSé˜²æŠ¤
      res.setHeader('X-XSS-Protection', '1; mode=block');

      // Referrer-Policy
      res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');

      next();
    };
  }
}
```

#### CSRFé˜²æŠ¤

**JWTæ–¹æ¡ˆæ— éœ€CSRF Tokenï¼š**

ä½¿ç”¨JWT + Authorization Headerçš„æ–¹æ¡ˆå¤©ç„¶é˜²å¾¡CSRFæ”»å‡»ï¼Œå› ä¸ºï¼š
1. JWTå­˜å‚¨åœ¨localStorageï¼Œæ¶æ„ç½‘ç«™æ— æ³•è¯»å–
2. è·¨åŸŸè¯·æ±‚æ— æ³•è‡ªåŠ¨æºå¸¦Authorization Header
3. æµè§ˆå™¨Same-Origin Policyä¿æŠ¤

**æ³¨æ„äº‹é¡¹ï¼š**
```typescript
// âœ… æ­£ç¡®ï¼šJWTå­˜å‚¨åœ¨localStorage
localStorage.setItem('n8n_token', token);

// âŒ é”™è¯¯ï¼šJWTå­˜å‚¨åœ¨Cookieï¼ˆä¼šå—CSRFæ”»å‡»ï¼‰
document.cookie = `token=${token}; HttpOnly`; // ä¸è¦è¿™æ ·åšï¼
```

---

### 1.4 SQLæ³¨å…¥é˜²æŠ¤ï¼ˆå·²å†…ç½®ï¼‰

**TypeORMè‡ªåŠ¨é˜²æŠ¤ï¼š**
```typescript
// âœ… TypeORMå‚æ•°åŒ–æŸ¥è¯¢ï¼Œè‡ªåŠ¨é˜²æŠ¤SQLæ³¨å…¥
const workflows = await this.workflowRepository.find({
  where: { projectId: userInput }, // è‡ªåŠ¨è½¬ä¹‰
});

// âœ… QueryBuilderä¹Ÿå®‰å…¨
const workflows = await this.workflowRepository
  .createQueryBuilder('workflow')
  .where('workflow.projectId = :projectId', { projectId: userInput })
  .getMany();

// âŒ å±é™©ç”¨æ³•ï¼Œå¿…é¡»é¿å…
const workflows = await this.workflowRepository.query(
  `SELECT * FROM workflow WHERE project_id = '${userInput}'`, // SQLæ³¨å…¥é£é™©ï¼
);
```

---

### 1.5 æ•æ„Ÿæ•°æ®åŠ å¯†ï¼ˆå·²å®ç°ï¼‰

**å‡­è¯åŠ å¯†æœåŠ¡ï¼š**
```typescript
// packages/cli/src/services/encryption.service.ts

@Service()
export class EncryptionService {
  private readonly algorithm = 'aes-256-gcm';
  private readonly encryptionKey: Buffer;

  constructor() {
    const key = process.env.ENCRYPTION_KEY || this.generateKey();
    this.encryptionKey = Buffer.from(key, 'hex');
  }

  /**
   * åŠ å¯†æ•æ„Ÿæ•°æ®
   */
  encrypt(plaintext: string): string {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(this.algorithm, this.encryptionKey, iv);

    let encrypted = cipher.update(plaintext, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const authTag = cipher.getAuthTag();

    return JSON.stringify({
      iv: iv.toString('hex'),
      data: encrypted,
      authTag: authTag.toString('hex'),
    });
  }

  /**
   * è§£å¯†æ•æ„Ÿæ•°æ®
   */
  decrypt(ciphertext: string): string {
    const { iv, data, authTag } = JSON.parse(ciphertext);

    const decipher = crypto.createDecipheriv(
      this.algorithm,
      this.encryptionKey,
      Buffer.from(iv, 'hex'),
    );

    decipher.setAuthTag(Buffer.from(authTag, 'hex'));

    let decrypted = decipher.update(data, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }

  private generateKey(): string {
    return crypto.randomBytes(32).toString('hex');
  }
}
```

**ä½¿ç”¨ç¤ºä¾‹ï¼š**
```typescript
// ä¿å­˜å‡­è¯æ—¶åŠ å¯†
const credential = this.credentialsRepository.create({
  name: 'OpenAI API Key',
  type: 'openai',
  data: this.encryptionService.encrypt(JSON.stringify({ apiKey: 'sk-...' })),
});

// è¯»å–å‡­è¯æ—¶è§£å¯†
const decryptedData = JSON.parse(
  this.encryptionService.decrypt(credential.data),
);
```

---

## äºŒã€æ€§èƒ½ä¼˜åŒ–ä½“ç³»

### 2.1 Redisç¼“å­˜ç­–ç•¥ï¼ˆP1ï¼‰

#### ç¼“å­˜å±‚è®¾è®¡

```typescript
// packages/cli/src/services/cache.service.ts

@Service()
export class CacheService {
  constructor(private readonly redis: Redis) {}

  /**
   * ç¼“å­˜å·¥ä½œç©ºé—´é…ç½®ï¼ˆ1å°æ—¶ï¼‰
   */
  async getWorkspaceConfig(workspaceId: string): Promise<Project | null> {
    const cacheKey = `workspace:config:${workspaceId}`;

    // å°è¯•ä»ç¼“å­˜è¯»å–
    const cached = await this.redis.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }

    // ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æ•°æ®åº“è¯»å–
    const workspace = await this.projectRepository.findOne({
      where: { id: workspaceId },
    });

    if (workspace) {
      // å†™å…¥ç¼“å­˜ï¼Œ1å°æ—¶è¿‡æœŸ
      await this.redis.setex(cacheKey, 3600, JSON.stringify(workspace));
    }

    return workspace;
  }

  /**
   * ç¼“å­˜å¹³å°æœåŠ¡åˆ—è¡¨ï¼ˆ10åˆ†é’Ÿï¼‰
   */
  async getPlatformServices(): Promise<PlatformService[]> {
    const cacheKey = 'platform:services:list';

    const cached = await this.redis.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }

    const services = await this.platformServiceRepository.find({
      where: { isActive: true },
    });

    await this.redis.setex(cacheKey, 600, JSON.stringify(services));
    return services;
  }

  /**
   * ç¼“å­˜ç”¨æˆ·æƒé™ï¼ˆ5åˆ†é’Ÿï¼‰
   */
  async getUserWorkspaceRole(
    userId: string,
    workspaceId: string,
  ): Promise<string | null> {
    const cacheKey = `user:${userId}:workspace:${workspaceId}:role`;

    const cached = await this.redis.get(cacheKey);
    if (cached) {
      return cached;
    }

    const relation = await this.projectRelationRepository.findOne({
      where: { userId, projectId: workspaceId },
    });

    if (relation) {
      await this.redis.setex(cacheKey, 300, relation.role);
      return relation.role;
    }

    return null;
  }

  /**
   * æ¸…é™¤å·¥ä½œç©ºé—´ç›¸å…³ç¼“å­˜
   */
  async invalidateWorkspaceCache(workspaceId: string): Promise<void> {
    const pattern = `workspace:*:${workspaceId}*`;
    const keys = await this.redis.keys(pattern);

    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}
```

#### ç¼“å­˜ç­–ç•¥è¡¨

| ç¼“å­˜å†…å®¹ | TTL | å¤±æ•ˆæ¡ä»¶ |
|---------|-----|----------|
| å·¥ä½œç©ºé—´é…ç½® | 1å°æ—¶ | å·¥ä½œç©ºé—´æ›´æ–°æ—¶ |
| å¹³å°æœåŠ¡åˆ—è¡¨ | 10åˆ†é’Ÿ | æœåŠ¡åˆ›å»º/æ›´æ–°æ—¶ |
| ç”¨æˆ·æƒé™ | 5åˆ†é’Ÿ | æƒé™å˜æ›´æ—¶ |
| å·¥ä½œæµåˆ—è¡¨ | 3åˆ†é’Ÿ | å·¥ä½œæµåˆ›å»º/åˆ é™¤æ—¶ |
| ä½™é¢ä¿¡æ¯ | 30ç§’ | å……å€¼/æ‰£è´¹æ—¶ |

---

### 2.2 æ•°æ®åº“è¿æ¥æ± ä¼˜åŒ–ï¼ˆP1ï¼‰

**TypeORMè¿æ¥æ± é…ç½®ï¼š**

```typescript
// packages/cli/src/databases/config.ts

export const dataSourceOptions: DataSourceOptions = {
  type: 'postgres',
  host: process.env.DB_POSTGRESDB_HOST,
  port: parseInt(process.env.DB_POSTGRESDB_PORT ?? '5432'),
  database: process.env.DB_POSTGRESDB_DATABASE,
  username: process.env.DB_POSTGRESDB_USER,
  password: process.env.DB_POSTGRESDB_PASSWORD,

  // âœ… è¿æ¥æ± é…ç½®
  extra: {
    // æœ€å¤§è¿æ¥æ•°
    max: parseInt(process.env.DB_POOL_MAX ?? '20'),

    // æœ€å°è¿æ¥æ•°
    min: parseInt(process.env.DB_POOL_MIN ?? '2'),

    // ç©ºé—²è¿æ¥è¶…æ—¶ï¼ˆ30ç§’ï¼‰
    idleTimeoutMillis: 30000,

    // è¿æ¥è¶…æ—¶ï¼ˆ2ç§’ï¼‰
    connectionTimeoutMillis: 2000,

    // è¯­å¥è¶…æ—¶ï¼ˆ10ç§’ï¼‰
    statement_timeout: 10000,
  },

  // âœ… æ…¢æŸ¥è¯¢æ—¥å¿—
  logging: ['error', 'warn', 'schema'],
  maxQueryExecutionTime: 500, // è¶…è¿‡500msè®°å½•æ—¥å¿—
};
```

**ç¯å¢ƒå˜é‡å»ºè®®ï¼š**
```bash
# å¼€å‘ç¯å¢ƒ
DB_POOL_MAX=10
DB_POOL_MIN=2

# ç”Ÿäº§ç¯å¢ƒ
DB_POOL_MAX=50
DB_POOL_MIN=10
```

---

### 2.3 æ‰¹é‡æ“ä½œä¼˜åŒ–ï¼ˆP1ï¼‰

#### æ‰¹é‡è®°å½•ä½¿ç”¨é‡

```typescript
// packages/cli/src/services/billing.service.ts

@Service()
export class BillingService {
  private usageQueue: UsageRecord[] = [];
  private flushInterval: NodeJS.Timeout;

  constructor() {
    // æ¯5ç§’æ‰¹é‡å†™å…¥ä¸€æ¬¡
    this.flushInterval = setInterval(() => this.flushUsageRecords(), 5000);
  }

  /**
   * æ·»åŠ ä½¿ç”¨è®°å½•åˆ°é˜Ÿåˆ—ï¼ˆå¼‚æ­¥ï¼‰
   */
  async queueUsageRecord(record: Partial<UsageRecord>): Promise<void> {
    this.usageQueue.push(this.usageRecordRepository.create(record));

    // é˜Ÿåˆ—æ»¡100æ¡ï¼Œç«‹å³åˆ·å†™
    if (this.usageQueue.length >= 100) {
      await this.flushUsageRecords();
    }
  }

  /**
   * æ‰¹é‡å†™å…¥ä½¿ç”¨è®°å½•
   */
  private async flushUsageRecords(): Promise<void> {
    if (this.usageQueue.length === 0) return;

    const records = [...this.usageQueue];
    this.usageQueue = [];

    try {
      // æ‰¹é‡æ’å…¥
      await this.usageRecordRepository
        .createQueryBuilder()
        .insert()
        .values(records)
        .execute();

      this.logger.debug('Flushed usage records', { count: records.length });
    } catch (error) {
      this.logger.error('Failed to flush usage records', { error });
      // å¤±è´¥çš„è®°å½•é‡æ–°åŠ å…¥é˜Ÿåˆ—
      this.usageQueue.unshift(...records);
    }
  }

  /**
   * ä¼˜é›…å…³é—­
   */
  async shutdown(): Promise<void> {
    clearInterval(this.flushInterval);
    await this.flushUsageRecords();
  }
}
```

---

### 2.4 æœˆåº¦ç»Ÿè®¡ä¼˜åŒ–ï¼ˆP1ï¼‰

#### PostgreSQL Upsert

```typescript
// packages/cli/src/services/billing.service.ts

/**
 * æ›´æ–°æœˆåº¦ç»Ÿè®¡ï¼ˆä½¿ç”¨Upsertï¼‰
 */
async updateMonthlyUsage(
  workspaceId: string,
  serviceKey: string,
  tokensUsed: number,
  amountCny: number,
): Promise<void> {
  const month = new Date().toISOString().slice(0, 7); // '2025-11'

  // âœ… PostgreSQL Upsert - é«˜æ€§èƒ½
  await this.monthlyUsageSummaryRepository
    .createQueryBuilder()
    .insert()
    .values({
      workspaceId,
      serviceKey,
      month,
      totalTokens: tokensUsed,
      totalCostCny: amountCny,
      callsCount: 1,
    })
    .orUpdate(
      ['total_tokens', 'total_cost_cny', 'calls_count'],
      ['workspace_id', 'service_key', 'month'],
      {
        overwrite: [
          'total_tokens = monthly_usage_summary.total_tokens + excluded.total_tokens',
          'total_cost_cny = monthly_usage_summary.total_cost_cny + excluded.total_cost_cny',
          'calls_count = monthly_usage_summary.calls_count + excluded.calls_count',
        ],
      },
    )
    .execute();
}
```

---

### 2.5 æ…¢æŸ¥è¯¢ä¼˜åŒ–ï¼ˆP2ï¼‰

#### æŸ¥è¯¢æ€§èƒ½ç›‘æ§

```typescript
// packages/cli/src/middlewares/query-logger.middleware.ts

@Service()
export class QueryLoggerMiddleware {
  handle(): RequestHandler {
    return async (req, res, next) => {
      const startTime = Date.now();

      // ç›‘å¬å“åº”ç»“æŸ
      res.on('finish', () => {
        const duration = Date.now() - startTime;

        if (duration > 500) {
          this.logger.warn('Slow request detected', {
            method: req.method,
            url: req.url,
            duration: `${duration}ms`,
            workspaceId: req.workspaceContext?.workspaceId,
          });
        }
      });

      next();
    };
  }
}
```

---

## ä¸‰ã€ç›‘æ§å‘Šè­¦ç³»ç»Ÿï¼ˆP1ï¼‰

### 3.1 å…³é”®æŒ‡æ ‡ç›‘æ§

```typescript
// packages/cli/src/services/monitoring.service.ts

@Service()
export class MonitoringService {
  constructor(
    private readonly projectRepository: Repository<Project>,
    private readonly usageRecordRepository: Repository<UsageRecord>,
  ) {}

  /**
   * æ£€æŸ¥ä½ä½™é¢å·¥ä½œç©ºé—´ï¼ˆæ¯åˆ†é’Ÿæ‰§è¡Œï¼‰
   */
  @Cron('0 * * * * *') // æ¯åˆ†é’Ÿ
  async checkLowBalanceWorkspaces(): Promise<void> {
    const lowBalanceCount = await this.projectRepository
      .createQueryBuilder('project')
      .where('project.balance_cny < project.low_balance_threshold_cny')
      .andWhere("project.status = 'active'")
      .getCount();

    if (lowBalanceCount > 100) {
      await this.alertService.send({
        level: 'warning',
        title: 'å¤§é‡å·¥ä½œç©ºé—´ä½™é¢ä¸è¶³',
        message: `å½“å‰æœ‰ ${lowBalanceCount} ä¸ªå·¥ä½œç©ºé—´ä½™é¢ä½äºé˜ˆå€¼`,
        notifyChannels: ['slack', 'email'],
      });
    }

    this.metricsService.gauge('workspaces.low_balance.count', lowBalanceCount);
  }

  /**
   * æ£€æŸ¥AIæœåŠ¡è°ƒç”¨å¤±è´¥ç‡ï¼ˆæ¯5åˆ†é’Ÿæ‰§è¡Œï¼‰
   */
  @Cron('0 */5 * * * *') // æ¯5åˆ†é’Ÿ
  async checkAiServiceFailureRate(): Promise<void> {
    const last5Min = new Date(Date.now() - 5 * 60 * 1000);

    const totalCalls = await this.usageRecordRepository
      .createQueryBuilder('usage')
      .where('usage.created_at > :time', { time: last5Min })
      .andWhere("usage.service_type = 'ai_model'")
      .getCount();

    const failedCalls = await this.usageRecordRepository
      .createQueryBuilder('usage')
      .where('usage.created_at > :time', { time: last5Min })
      .andWhere("usage.service_type = 'ai_model'")
      .andWhere("usage.metadata->>'status' = 'failed'")
      .getCount();

    const failureRate = totalCalls > 0 ? (failedCalls / totalCalls) * 100 : 0;

    if (failureRate > 5) {
      await this.alertService.send({
        level: 'critical',
        title: 'AIæœåŠ¡è°ƒç”¨å¤±è´¥ç‡è¿‡é«˜',
        message: `è¿‡å»5åˆ†é’Ÿå¤±è´¥ç‡: ${failureRate.toFixed(2)}% (${failedCalls}/${totalCalls})`,
        notifyChannels: ['pagerduty', 'slack'],
      });
    }

    this.metricsService.gauge('ai_service.failure_rate', failureRate);
  }

  /**
   * æ£€æŸ¥æ•°æ®åº“æ…¢æŸ¥è¯¢ï¼ˆå®æ—¶ï¼‰
   */
  async checkSlowQueries(): Promise<void> {
    // æŸ¥è¯¢pg_stat_statements
    const slowQueries = await this.projectRepository.query(`
      SELECT
        query,
        calls,
        mean_exec_time,
        max_exec_time
      FROM pg_stat_statements
      WHERE mean_exec_time > 500
      ORDER BY mean_exec_time DESC
      LIMIT 10
    `);

    if (slowQueries.length > 0) {
      this.logger.warn('Slow queries detected', { slowQueries });
    }
  }
}
```

### 3.2 å‘Šè­¦é…ç½®

| æŒ‡æ ‡ | é˜ˆå€¼ | å‘Šè­¦çº§åˆ« | é€šçŸ¥æ¸ é“ |
|------|------|---------|---------|
| ä½ä½™é¢å·¥ä½œç©ºé—´æ•° | > 100 | Warning | Slack, Email |
| AIæœåŠ¡å¤±è´¥ç‡ | > 5% | Critical | PagerDuty, Slack |
| APIå“åº”æ—¶é—´ | > 500ms | Warning | Slack |
| æ•°æ®åº“è¿æ¥æ•° | > 80% | Critical | PagerDuty |
| Rediså†…å­˜ä½¿ç”¨ç‡ | > 80% | Warning | Slack |
| ç£ç›˜ä½¿ç”¨ç‡ | > 85% | Critical | PagerDuty, Email |

---

## å››ã€å®æ–½æ£€æŸ¥æ¸…å•

### P0çº§åˆ«ï¼ˆå¿…é¡»å®æ–½ï¼Œå½±å“ä¸Šçº¿ï¼‰

- [ ] **å¹¶å‘å®‰å…¨**ï¼šBillingServiceä½¿ç”¨æ‚²è§‚é”
- [ ] **APIé™æµ**ï¼šæ‰€æœ‰å¹³å°æœåŠ¡æ¥å£æ·»åŠ é™æµ
- [ ] **æ•æ„Ÿæ•°æ®åŠ å¯†**ï¼šEncryptionServiceåŠ å¯†å‡­è¯
- [ ] **å®‰å…¨å¤´éƒ¨**ï¼šSecurityHeadersMiddlewareé…ç½®CSP

### P1çº§åˆ«ï¼ˆåº”è¯¥å®æ–½ï¼Œå½±å“ä½“éªŒï¼‰

- [ ] **Redisç¼“å­˜**ï¼šå·¥ä½œç©ºé—´é…ç½®ã€å¹³å°æœåŠ¡åˆ—è¡¨ç¼“å­˜
- [ ] **æ•°æ®åº“è¿æ¥æ± **ï¼šç”Ÿäº§ç¯å¢ƒè¿æ¥æ± é…ç½®
- [ ] **æ‰¹é‡æ“ä½œ**ï¼šUsageRecordæ‰¹é‡å†™å…¥
- [ ] **ç›‘æ§å‘Šè­¦**ï¼šä½ä½™é¢ã€å¤±è´¥ç‡å‘Šè­¦

### P2çº§åˆ«ï¼ˆå¯ä»¥å®æ–½ï¼Œä¼˜åŒ–ä½“éªŒï¼‰

- [ ] **æ…¢æŸ¥è¯¢ç›‘æ§**ï¼šQueryLoggerMiddlewareè®°å½•æ…¢è¯·æ±‚
- [ ] **æœˆåº¦ç»Ÿè®¡ä¼˜åŒ–**ï¼šPostgreSQL Upsert
- [ ] **ç¼“å­˜é¢„çƒ­**ï¼šç³»ç»Ÿå¯åŠ¨æ—¶é¢„åŠ è½½çƒ­æ•°æ®

---

## äº”ã€æ€§èƒ½åŸºå‡†æµ‹è¯•

### 5.1 æµ‹è¯•åœºæ™¯

| åœºæ™¯ | QPSç›®æ ‡ | å“åº”æ—¶é—´ | è¯´æ˜ |
|------|---------|---------|------|
| è·å–å·¥ä½œæµåˆ—è¡¨ | 1000 | < 100ms | æœ‰ç¼“å­˜ |
| AIæœåŠ¡è°ƒç”¨ | 500 | < 2s | åŒ…æ‹¬OpenAI APIæ—¶é—´ |
| RAGæŸ¥è¯¢ | 200 | < 3s | åŒ…æ‹¬å‘é‡æœç´¢æ—¶é—´ |
| å·¥ä½œç©ºé—´åˆ‡æ¢ | 2000 | < 50ms | çº¯ç¼“å­˜è¯»å– |
| ä½™é¢æ‰£è´¹ | 1000 | < 50ms | æ‚²è§‚é”åœºæ™¯ |

### 5.2 å‹åŠ›æµ‹è¯•å·¥å…·

```bash
# ä½¿ç”¨ k6 è¿›è¡Œå‹åŠ›æµ‹è¯•
k6 run --vus 100 --duration 60s tests/load/billing.js

# æˆ–ä½¿ç”¨ ab (Apache Bench)
ab -n 10000 -c 100 http://localhost:5678/rest/workspaces
```

---

**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v1.0
**æœ€åæ›´æ–°ï¼š** 2025-11-07
**ä¼˜å…ˆçº§ï¼š** P0 - å¿…é¡»å®æ–½
**é¢„è®¡å·¥æ—¶ï¼š** 3-4å‘¨
