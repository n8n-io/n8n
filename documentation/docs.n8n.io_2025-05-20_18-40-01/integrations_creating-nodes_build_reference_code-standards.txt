URL: https://docs.n8n.io/integrations/creating-nodes/build/reference/code-standards/
Scraped_At: 2025-05-20T19:08:35.151052

Code standards
#
Following defined code standards when building your node makes your code more readable and maintainable, and helps avoid errors. This document provides guidance on good code practices for node building. It focuses on code details. For UI standards and UX guidance, refer to
Node UI design
.
Use the linter
#
The n8n node linter provides automatic checking for many of the node-building standards. You should ensure your node passes the linter's checks before publishing it. Refer to the
n8n node linter
documentation for more information.
Use the starter
#
The n8n node starter project includes a recommended setup, dependencies (including the linter), and examples to help you get started. Begin new projects with the
starter
.
Write in TypeScript
#
All n8n code is TypeScript. Writing your nodes in TypeScript can speed up development and reduce bugs.
Detailed guidelines for writing a node
#
These guidelines apply to any node you build.
Resources and operations
#
If your node can perform several operations, call the parameter that sets the operation
Operation
. If your node can do these operations on more than one resource, create a
Resource
parameter. The following code sample shows a basic resource and operations setup:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
export
const
ExampleNode
implements
INodeType
{
description
:
{
displayName
:
'Example Node'
,
...
properties
:
[
{
displayName
:
'Resource'
,
name
:
'resource'
,
type
:
'options'
,
options
:
[
{
name
:
'Resource One'
,
value
:
'resourceOne'
},
{
name
:
'Resource Two'
,
value
:
'resourceTwo'
}
],
default
:
'resourceOne'
},
{
displayName
:
'Operation'
,
name
:
'operation'
,
type
:
'options'
,
// Only show these operations for Resource One
displayOptions
:
{
show
:
{
resource
:
[
'resourceOne'
]
}
},
options
:
[
{
name
:
'Create'
,
value
:
'create'
,
description
:
'Create an instance of Resource One'
}
]
}
]
}
}
Reuse internal parameter names
#
All resource and operation fields in an n8n node have two settings: a display name, set using the
name
parameter, and an internal name, set using the
value
parameter. Reusing the internal name for fields allows n8n to preserve user-entered data if a user switches operations.
For example: you're building a node with a resource named 'Order'. This resource has several operations, including Get, Edit, and Delete. Each of these operations uses an order ID to perform the operation on the specified order. You need to display an ID field for the user. This field has a display label, and an internal name. By using the same internal name (set in
value
) for the operation ID field on each resource, a user can enter the ID with the Get operation selected, and not lose it if they switch to Edit.
When reusing the internal name, you must ensure that only one field is visible to the user at a time. You can control this using
displayOptions
.
Detailed guidelines for writing a programmatic-style node
#
These guidelines apply when building nodes using the programmatic node-building style. They aren't relevant when using the declarative style. For more information on different node-building styles, refer to
Choose your node building approach
.
Don't change incoming data
#
Never change the incoming data a node receives (data accessible with
this.getInputData()
) as all nodes share it. If you need to add, change, or delete data, clone the incoming data and return the new data. If you don't do this, sibling nodes that execute after the current one will operate on the altered data and process incorrect data.
It's not necessary to always clone all the data. For example, if a node changes the binary data but not the JSON data, you can create a new item that reuses the reference to the JSON item.
Use the built in request library
#
Some third-party services have their own libraries on npm, which make it easier to create an integration. The problem with these packages is that you add another dependency (plus all the dependencies of the dependencies). This adds more and more code, which has to be loaded, can introduce security vulnerabilities, bugs, and so on. Instead, use the built-in module:
1
2
3
4
5
6
7
8
9
// If no auth needed
const
response
=
await
this
.
helpers
.
httpRequest
(
options
);
// If auth needed
const
response
=
await
this
.
helpers
.
httpRequestWithAuthentication
.
call
(
this
,
'credentialTypeName'
,
// For example: pipedriveApi
options
,
);
This uses the npm package
Axios
.
Refer to
HTTP helpers
for more information, and for migration instructions for the removed
this.helpers.request
.
Was this page helpful?
Thanks for your feedback!
Thanks for your feedback! Help us improve this page by submitting an issue or a fix in our
GitHub repo
.