# 分支同步指南

## ⚠️ 二次开发特别说明

### 许可证移除现状

**重要**: 本仓库已于 2025-11-03 完全移除所有许可证验证系统（提交 901b241429）

**移除范围**:
- 删除 15+ 个许可证核心文件
- 清理 151 个文件中的许可证引用
- 移除所有 `@Licensed` 装饰器
- 删除 `License` 服务和 `LicenseState` 类
- 所有企业功能默认启用

**同步风险**: 上游 n8n 项目持续开发，**每次更新都可能重新引入许可证检查代码**

---

## 上游同步合并策略

### 🎯 合并原则

由于已移除许可证系统，与上游同步时**必须**遵循以下原则：

#### 1. 不能直接合并的情况

**绝对禁止**自动合并以下类型的上游更新：
- ❌ 新增或修改许可证相关文件
- ❌ 添加 `@Licensed` 装饰器
- ❌ 引入新的许可证检查逻辑
- ❌ 添加许可证相关中间件
- ❌ 新增企业功能限制

#### 2. 可以合并但需要修改的情况

以下更新**可以合并，但合并后必须移除许可证相关代码**：
- ⚠️ 新功能包含许可证检查
- ⚠️ Bug 修复涉及许可证逻辑
- ⚠️ API 端点新增许可证中间件
- ⚠️ 前端组件包含 `EnterpriseEdition` 包装

#### 3. 可以直接合并的情况

以下更新**可以安全合并**：
- ✅ 纯 Bug 修复（不涉及许可证）
- ✅ 新增节点/集成
- ✅ UI 改进（不涉及企业功能限制）
- ✅ 性能优化
- ✅ 文档更新
- ✅ 依赖包更新（非 license-sdk）

### 📋 同步前检查清单

每次准备从上游同步前，**必须**完成以下检查：

```bash
# 1. 查看上游新增的提交
git fetch upstream
git log master..upstream/master --oneline

# 2. 检查是否有许可证相关的更新
git log master..upstream/master --grep="license" --grep="Licensed" --grep="enterprise" -i

# 3. 查看具体变更的文件
git diff master..upstream/master --name-only | grep -E "(license|enterprise)" -i

# 4. 检查是否有新的 @Licensed 装饰器
git diff master..upstream/master | grep -E "@Licensed|@licensed"

# 5. 检查是否有新的许可证依赖
git diff master..upstream/master -- pnpm-lock.yaml | grep -i license
```

### 🔄 推荐的同步流程

#### 方案A：逐提交审查合并（推荐）

**适用场景**: 上游有较多提交，需要精确控制

```bash
# 1. 创建临时同步分支
git checkout -b sync/upstream-$(date +%Y%m%d)

# 2. 获取上游更新
git fetch upstream

# 3. 查看上游提交列表
git log --oneline master..upstream/master

# 4. 逐个挑选提交（cherry-pick）
# 对每个提交判断是否包含许可证代码
git cherry-pick <commit-hash>  # 不包含许可证的提交

# 5. 对包含许可证的提交，手动应用并修改
git show <commit-hash> > temp.patch
# 手动审查 temp.patch，移除许可证相关代码
# 手动应用修改后的代码

# 6. 完成后测试
pnpm build
pnpm typecheck

# 7. 合并到 master
git checkout master
git merge sync/upstream-$(date +%Y%m%d)
```

#### 方案B：整体合并后清理（适合小更新）

**适用场景**: 上游更新较少，许可证相关代码可控

```bash
# 1. 创建临时同步分支
git checkout -b sync/upstream-$(date +%Y%m%d)

# 2. 尝试合并上游 master
git fetch upstream
git merge upstream/master

# 3. 解决冲突（优先保留我们的无许可证版本）

# 4. 合并后立即检查许可证代码
./scripts/check-license-code.sh  # 见下方自动化脚本

# 5. 手动移除新引入的许可证代码
# 参考 '二次开发进度说明.md' 中的删除策略

# 6. 验证所有企业功能仍然启用
# 运行功能测试

# 7. 提交清理后的代码
git add .
git commit -m "同步上游更新并移除许可证代码"

# 8. 合并到 master
git checkout master
git merge sync/upstream-$(date +%Y%m%d)
```

### 🛠️ 许可证代码检测脚本

创建 `scripts/check-license-code.sh` 帮助自动检测：

```bash
#!/bin/bash
# 检测代码中是否重新引入许可证相关代码

echo "🔍 检查许可证相关代码..."

# 检查许可证文件
LICENSE_FILES=$(find packages -type f -path "*/license/*" 2>/dev/null | wc -l)
if [ $LICENSE_FILES -gt 0 ]; then
    echo "❌ 发现许可证目录或文件"
    find packages -type f -path "*/license/*"
fi

# 检查 @Licensed 装饰器
LICENSED_DECORATOR=$(grep -r "@Licensed" packages --include="*.ts" --exclude-dir=node_modules 2>/dev/null | wc -l)
if [ $LICENSED_DECORATOR -gt 0 ]; then
    echo "❌ 发现 @Licensed 装饰器使用"
    grep -r "@Licensed" packages --include="*.ts" --exclude-dir=node_modules
fi

# 检查 License 类引用
LICENSE_IMPORT=$(grep -r "from.*license" packages --include="*.ts" --exclude-dir=node_modules | grep -v "// @ts-ignore" | wc -l)
if [ $LICENSE_IMPORT -gt 0 ]; then
    echo "❌ 发现 License 相关导入"
    grep -r "from.*license" packages --include="*.ts" --exclude-dir=node_modules | head -20
fi

# 检查 LICENSE_FEATURES 常量
LICENSE_FEATURES=$(grep -r "LICENSE_FEATURES\|LICENSE_QUOTAS" packages --include="*.ts" --exclude-dir=node_modules 2>/dev/null | wc -l)
if [ $LICENSE_FEATURES -gt 0 ]; then
    echo "❌ 发现 LICENSE_FEATURES 或 LICENSE_QUOTAS 使用"
fi

# 检查 license-sdk 依赖
LICENSE_SDK=$(grep -r "license-sdk" pnpm-lock.yaml 2>/dev/null | wc -l)
if [ $LICENSE_SDK -gt 0 ]; then
    echo "❌ 发现 license-sdk 依赖"
fi

# 检查 EnterpriseEdition 组件
ENTERPRISE_COMP=$(grep -r "EnterpriseEdition" packages/frontend --include="*.vue" --include="*.ts" 2>/dev/null | wc -l)
if [ $ENTERPRISE_COMP -gt 0 ]; then
    echo "❌ 发现 EnterpriseEdition 组件使用"
fi

echo ""
echo "✅ 检查完成"
```

### 🔧 冲突解决策略

#### 许可证相关冲突

**原则**: 始终选择"无许可证检查"的版本

```bash
# 场景1: 上游新增许可证检查，本地无此文件
# 策略: 接受上游代码，然后手动移除许可证部分
git checkout --theirs <file>
# 然后手动编辑文件，移除许可证代码

# 场景2: 上游修改包含许可证，本地已移除
# 策略: 保留本地版本，手动应用非许可证相关的修改
git checkout --ours <file>
# 查看上游修改: git show upstream/master:<file>
# 手动应用有用的修改

# 场景3: 双方都修改了同一个函数
# 策略: 手动合并，确保许可证检查被移除
# 打开编辑器手动解决
```

#### 具体文件类型的处理

**1. 控制器文件 (*.controller.ts)**
```typescript
// ❌ 上游可能添加
@Licensed('feat:someFeature')
async someMethod() { ... }

// ✅ 我们的版本（移除装饰器）
async someMethod() { ... }

// 策略: 保留方法，移除 @Licensed 装饰器
```

**2. 服务文件 (*.service.ts)**
```typescript
// ❌ 上游可能添加
if (this.license.isFeatureEnabled('feat:xxx')) {
  return feature();
}
return null;

// ✅ 我们的版本（直接返回）
return feature();

// 策略: 移除条件检查，直接执行功能
```

**3. 前端组件 (*.vue)**
```vue
<!-- ❌ 上游可能添加 -->
<EnterpriseEdition :feature="['feat:xxx']">
  <FeatureComponent />
</EnterpriseEdition>

<!-- ✅ 我们的版本（移除包装） -->
<FeatureComponent />

<!-- 策略: 移除 EnterpriseEdition 包装，直接使用组件 -->
```

### ✅ 合并后验证清单

每次同步上游后，**必须**完成以下验证：

#### 1. 代码检查
```bash
# 运行许可证检测脚本
./scripts/check-license-code.sh

# TypeScript 类型检查
pnpm typecheck

# 代码质量检查
pnpm lint

# 完整构建
pnpm build
```

#### 2. 功能验证

启动应用并验证所有企业功能：

- [ ] 应用能正常启动
- [ ] 无许可证相关错误日志
- [ ] 所有企业功能菜单可见
- [ ] LDAP/SAML/OIDC 配置可访问
- [ ] 变量管理功能可用
- [ ] Source Control 功能可用
- [ ] 工作流历史功能可用
- [ ] 可创建无限团队项目
- [ ] 高级权限设置可用
- [ ] API 全部可访问

#### 3. 回归测试

```bash
# 运行核心测试
pnpm test

# 测试关键企业功能
# - 创建团队项目
# - 分享工作流
# - 使用变量
# - 查看工作流历史
```

### 📝 合并提交信息规范

合并上游更新时，提交信息应清晰说明：

```
同步上游更新: <上游版本/日期>

**上游提交范围**: <起始hash>..<结束hash>

**主要更新内容**:
- 功能1: 描述
- 功能2: 描述
- Bug修复: 描述

**许可证代码处理**:
- 移除文件: <列表>
- 移除装饰器: <文件列表>
- 移除检查逻辑: <文件列表>

**验证状态**:
- ✅ 构建成功
- ✅ 类型检查通过
- ✅ 企业功能正常
- ✅ 无许可证代码残留

参考: 二次开发进度说明.md
```

---

## 自动同步说明

### Master 分支
- **自动同步**：GitHub Actions 每天自动同步上游更新
- **时间**：每天 UTC 0 点（北京时间 08:00）
- **范围**：仅同步到 `master` 分支
- **状态**：可以在 GitHub Actions 页面查看执行结果
- **⚠️ 注意**: 自动同步后**必须人工审查**并移除新引入的许可证代码

### 开发分支
- **手动同步**：开发者根据需要自行同步
- **方式**：通过 Git 命令手动合并
- **决策**：由开发团队根据当前开发进度决定

## 手动同步开发分支

### 场景 1：开发分支需要最新上游更新

```bash
# 1. 切换到要更新的开发分支
git checkout feature/your-feature-branch

# 2. 先更新本地 master
git checkout master
git pull origin master

# 3. 将 master 合并到开发分支
git checkout feature/your-feature-branch
git merge master

# 4. 解决冲突（如果有）
# 编辑冲突文件后：
git add <冲突文件>
git commit -m "合并：同步上游更新到开发分支"

# 5. 运行许可证检查
./scripts/check-license-code.sh

# 6. 推送到远程
git push origin feature/your-feature-branch
```

### 场景 2：从上游直接同步特定功能

```bash
# 1. 添加上游仓库（如果还没有）
git remote add upstream https://github.com/n8n-io/n8n.git

# 2. 获取上游更新
git fetch upstream

# 3. 检查目标提交是否包含许可证代码
git show <commit-hash> | grep -i "license\|licensed"

# 4. 切换到开发分支
git checkout feature/your-feature-branch

# 5. 从上游 master 合并特定提交
git cherry-pick <commit-hash>

# 6. 如果包含许可证代码，立即移除
# 参考二次开发进度说明.md

# 7. 解决冲突并推送
```

## 最佳实践

### 何时同步开发分支

1. **项目启动时**：创建新开发分支后，应立即与 master 同步
2. **定期同步**：建议每周或每两周同步一次，避免冲突积累
3. **开发间隙**：完成一个功能模块后同步更新
4. **紧急修复**：上游有重要安全或 Bug 修复时优先同步
5. **⚠️ 许可证风险评估**：每次同步前先评估上游是否引入新的许可证代码

### 同步频率建议

考虑到许可证移除的特殊性：

- **Master 分支**: 自动同步但需要人工审查
- **开发分支**: 根据实际情况，建议：
  - 🟢 **安全更新**: 立即同步（检查后）
  - 🟡 **功能更新**: 每2-4周同步一次
  - 🔴 **大版本更新**: 谨慎评估，可能需要重新应用许可证移除

### 创建同步脚本

```bash
# 创建同步脚本 sync-branch.sh
#!/bin/bash
BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)

echo "🔄 同步分支 $BRANCH_NAME 到最新 master"

# 检查是否有未提交的更改
if [[ -n $(git status -s) ]]; then
    echo "❌ 有未提交的更改，请先提交或暂存"
    exit 1
fi

git checkout master
git pull origin master
git checkout $BRANCH_NAME
git merge master

if [ $? -ne 0 ]; then
    echo "⚠️  合并出现冲突，请手动解决"
    exit 1
fi

echo "🔍 检查许可证代码..."
./scripts/check-license-code.sh

echo "✅ 同步完成，请运行测试并检查许可证代码"
echo "💡 建议运行: pnpm build && pnpm typecheck"
```

## 注意事项

⚠️ **重要提醒**

### 通用注意事项
- 始终在独立分支上进行开发，避免直接在 master 分支工作
- 同步前确保当前分支的修改已提交或暂存
- 大型功能开发期间建议减少同步频率，避免频繁冲突
- 同步后及时测试功能是否正常

### 许可证移除相关（重要！）
- ⚠️ **每次同步后必须检查是否重新引入许可证代码**
- ⚠️ **合并冲突时，优先保留无许可证检查的版本**
- ⚠️ **不要直接接受上游的许可证相关文件**
- ⚠️ **合并后立即运行许可证检测脚本**
- ⚠️ **保持 `二次开发进度说明.md` 的更新**

## 常见问题

**Q：开发分支落后太多，同步困难怎么办？**
A：
1. 在 master 上创建新分支：git checkout -b feature/new-branch-from-master
2. 手动移植代码到新分支
3. 废弃旧分支

**Q：可以跳过测试直接同步吗？**
A：不建议。同步后应运行测试确保功能正常。
```bash
pnpm install
pnpm build
pnpm typecheck
pnpm test
./scripts/check-license-code.sh  # 必须运行
```

**Q：如何查看上游有哪些新提交？**
A：
```bash
git log --oneline master..upstream/master
# 同时检查许可证相关提交
git log master..upstream/master --grep="license" -i
```

**Q：上游重新引入了许可证代码，如何快速清理？**
A：
1. 参考 `二次开发进度说明.md` 中的删除策略
2. 使用 `git diff 901b241429..HEAD` 查看与许可证移除提交的差异
3. 手动恢复许可证移除的状态
4. 运行 `./scripts/check-license-code.sh` 验证

**Q：自动同步的 master 分支引入了许可证代码怎么办？**
A：
1. 立即创建修复分支：`git checkout -b fix/remove-license-$(date +%Y%m%d)`
2. 移除许可证代码
3. 提交并合并回 master
4. 通知团队不要使用包含许可证的版本

**Q：如何判断某个上游提交是否安全合并？**
A：
```bash
# 查看提交内容
git show <commit-hash>

# 检查是否包含许可证关键词
git show <commit-hash> | grep -iE "license|@licensed|enterprise.*check|isLicensed"

# 查看修改的文件
git show <commit-hash> --name-only | grep -iE "license|enterprise"
```

## 应急预案

### 场景：意外合并了大量许可证代码

**立即行动**:
```bash
# 1. 创建紧急修复分支
git checkout -b emergency/revert-license

# 2. 回滚到许可证移除提交
git reset --hard 901b241429

# 3. 重新应用上游有用的提交（逐个cherry-pick）
git cherry-pick <good-commit-hash>

# 4. 验证
./scripts/check-license-code.sh
pnpm build

# 5. 强制推送（谨慎！）
# git push -f origin master  # 仅在紧急情况
```

### 场景：无法确定如何处理许可证相关冲突

**处理流程**:
1. **暂停合并**: `git merge --abort`
2. **创建测试分支**: 在测试分支上尝试不同策略
3. **咨询文档**: 查看 `二次开发进度说明.md`
4. **团队讨论**: 与团队成员讨论最佳方案
5. **记录决策**: 更新文档说明处理方式

## 维护文档

每次重要的上游同步后，请更新以下文档：

1. **二次开发进度说明.md** - 如果删除了新的许可证代码
2. **本文件** - 如果发现了新的合并策略或最佳实践
3. **Git 提交信息** - 详细记录许可证代码的处理

## 联系支持

如遇到同步问题，请：
1. 查阅 `二次开发进度说明.md` 了解许可证移除的详细内容
2. 运行 `./scripts/check-license-code.sh` 自动检测
3. 联系技术负责人或在团队频道寻求帮助
4. 必要时创建 issue 记录问题和解决方案

---

*最后更新: 2025-11-03*
*维护者: 开发团队*
