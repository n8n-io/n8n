#!/usr/bin/env node

import { writeFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { discoverExtensions } from './discover-cloud-extensions.mjs';

const __dirname = dirname(fileURLToPath(import.meta.url));
const OUTPUT_PATH = join(__dirname, '../src/app/plugins/extension-loader/registry.generated.ts');

/**
 * Convert extension name to i18n namespace
 * @example '@n8n/ce-test-extension' -> 'ce.testExtension'
 */
function extensionNameToNamespace(extensionName) {
	const withoutPrefix = extensionName.replace(/^@n8n\/ce-/, '');
	const camelCase = withoutPrefix.replace(/-([a-z0-9])/g, (_, char) => char.toUpperCase());
	return `ce.${camelCase}`;
}

/**
 * Recursively extract all keys from a locale object
 * @param {object} obj - The locale object
 * @param {string} prefix - Current key prefix
 * @returns {string[]} - Array of all keys
 */
function extractLocaleKeys(obj, prefix = '') {
	const keys = [];
	for (const [key, value] of Object.entries(obj)) {
		const fullKey = prefix ? `${prefix}.${key}` : key;
		if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
			keys.push(...extractLocaleKeys(value, fullKey));
		} else {
			keys.push(fullKey);
		}
	}
	return keys;
}

/**
 * Generate i18n type augmentation code for a single extension
 */
function generateExtensionI18nTypesCode(extension) {
	if (!extension.locales) return null;

	const namespace = extensionNameToNamespace(extension.name);
	const enLocale = extension.locales.en;
	if (!enLocale) return null;

	const keys = extractLocaleKeys(enLocale);
	if (keys.length === 0) return null;

	const keyEntries = keys.map((k) => `		'${namespace}.${k}': true;`).join('\n');

	return `// This file is auto-generated by editor-ui/scripts/generate-cloud-extension-registry.mjs
// Do not edit manually!

/**
 * Module augmentation to add this extension's locale keys to @n8n/i18n's BaseTextKey type.
 * This allows i18n.baseText() to accept extension-specific translation keys with full type safety.
 */
declare module '@n8n/i18n' {
	interface ExtensionLocaleKeys {
${keyEntries}
	}
}

export {};
`;
}

function generateRegistryCode(extensions) {
	// Generate static imports at the top
	const imports = extensions
		.map((p, idx) => {
			return `// @ts-expect-error This is resolved in vite
import * as extension${idx} from '${p.resolvedName}/index';`;
		})
		.join('\n');

	const entries = extensions
		.map((p, idx) => {
			return `  {
    name: '${p.name}',
    resolvedName: '${p.resolvedName}',
    module: extension${idx},
    shouldLoad: extension${idx}.default?.shouldLoad,
  },`;
		})
		.join('\n');

	return `// This file is auto-generated by scripts/generate-extension-registry.mjs
// Do not edit manually!

/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */

import type { CloudExtension } from '@n8n/extension-sdk/cloud';

${imports}

export interface ExtensionDefinition {
  name: string;
  resolvedName: string;
  module: { default: CloudExtension };
  shouldLoad?: () => Promise<boolean>;
}

export const EXTENSIONS: ExtensionDefinition[] = [
${entries}
];
`;
}

async function generateExtensionRegistry() {
	console.log('ğŸ” Discovering extensions...');
	const extensions = await discoverExtensions();

	console.log('ğŸ“ Generating extension registry...');
	const code = generateRegistryCode(extensions);

	writeFileSync(OUTPUT_PATH, code, 'utf-8');
	console.log(`âœ“ Generated extension registry: ${OUTPUT_PATH}`);

	// Generate per-extension locale type files
	console.log('ğŸ“ Generating extension locale types...');
	for (const extension of extensions) {
		const extensionTypesCode = generateExtensionI18nTypesCode(extension);
		if (extensionTypesCode) {
			const outputPath = join(extension.path, 'src/locales.generated.ts');
			writeFileSync(outputPath, extensionTypesCode, 'utf-8');
			console.log(`âœ“ Generated: ${outputPath}`);
		}
	}

	console.log('');
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
	generateExtensionRegistry().catch((error) => {
		console.error('âŒ Registry generation failed:', error);
		process.exit(1);
	});
}

export { generateExtensionRegistry };
