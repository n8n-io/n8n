'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const jest_mock_extended_1 = require('jest-mock-extended');
const n8n_workflow_1 = require('n8n-workflow');
const waiting_forms_1 = require('@/webhooks/waiting-forms');
describe('WaitingForms', () => {
	const executionRepository = (0, jest_mock_extended_1.mock)();
	const waitingForms = new waiting_forms_1.WaitingForms(
		(0, jest_mock_extended_1.mock)(),
		(0, jest_mock_extended_1.mock)(),
		executionRepository,
		(0, jest_mock_extended_1.mock)(),
	);
	beforeEach(() => {
		jest.restoreAllMocks();
	});
	describe('findCompletionPage', () => {
		it('should return lastNodeExecuted if it is a non-disabled form completion node', () => {
			const workflow = (0, jest_mock_extended_1.mock)({
				getParentNodes: jest.fn().mockReturnValue([]),
				nodes: {
					Form1: {
						disabled: undefined,
						type: n8n_workflow_1.FORM_NODE_TYPE,
						parameters: {
							operation: 'completion',
						},
					},
				},
			});
			const result = waitingForms.findCompletionPage(workflow, {}, 'Form1');
			expect(result).toBe('Form1');
		});
		it('should return undefined if lastNodeExecuted is disabled', () => {
			const workflow = (0, jest_mock_extended_1.mock)({
				getParentNodes: jest.fn().mockReturnValue([]),
				nodes: {
					Form1: {
						disabled: true,
						type: n8n_workflow_1.FORM_NODE_TYPE,
						parameters: {
							operation: 'completion',
						},
					},
				},
			});
			const result = waitingForms.findCompletionPage(workflow, {}, 'Form1');
			expect(result).toBeUndefined();
		});
		it('should return undefined if lastNodeExecuted is not a form node', () => {
			const workflow = (0, jest_mock_extended_1.mock)({
				getParentNodes: jest.fn().mockReturnValue([]),
				nodes: {
					NonForm: {
						disabled: undefined,
						type: 'other-node-type',
						parameters: {},
					},
				},
			});
			const result = waitingForms.findCompletionPage(workflow, {}, 'NonForm');
			expect(result).toBeUndefined();
		});
		it('should return undefined if lastNodeExecuted operation is not completion', () => {
			const workflow = (0, jest_mock_extended_1.mock)({
				getParentNodes: jest.fn().mockReturnValue([]),
				nodes: {
					Form1: {
						disabled: undefined,
						type: n8n_workflow_1.FORM_NODE_TYPE,
						parameters: {
							operation: 'page',
						},
					},
				},
			});
			const result = waitingForms.findCompletionPage(workflow, {}, 'Form1');
			expect(result).toBeUndefined();
		});
		it('should find first valid completion form in parent nodes if lastNodeExecuted is not valid', () => {
			const workflow = (0, jest_mock_extended_1.mock)({
				getParentNodes: jest.fn().mockReturnValue(['Form1', 'Form2', 'Form3']),
				nodes: {
					LastNode: {
						disabled: undefined,
						type: 'other-node-type',
						parameters: {},
					},
					Form1: {
						disabled: true,
						type: n8n_workflow_1.FORM_NODE_TYPE,
						parameters: {
							operation: 'completion',
						},
					},
					Form2: {
						disabled: undefined,
						type: n8n_workflow_1.FORM_NODE_TYPE,
						parameters: {
							operation: 'completion',
						},
					},
					Form3: {
						disabled: undefined,
						type: n8n_workflow_1.FORM_NODE_TYPE,
						parameters: {
							operation: 'completion',
						},
					},
				},
			});
			const runData = {
				Form2: [],
				Form3: [],
			};
			const result = waitingForms.findCompletionPage(workflow, runData, 'LastNode');
			expect(result).toBe('Form3');
		});
		it('should return undefined if no valid completion form is found in parent nodes', () => {
			const workflow = (0, jest_mock_extended_1.mock)({
				getParentNodes: jest.fn().mockReturnValue(['Form1', 'Form2']),
				nodes: {
					LastNode: {
						disabled: undefined,
						type: 'other-node-type',
						parameters: {},
					},
					Form1: {
						disabled: true,
						type: n8n_workflow_1.FORM_NODE_TYPE,
						parameters: {
							operation: 'completion',
						},
					},
					Form2: {
						disabled: undefined,
						type: n8n_workflow_1.FORM_NODE_TYPE,
						parameters: {
							operation: 'submit',
						},
					},
				},
			});
			const result = waitingForms.findCompletionPage(workflow, {}, 'LastNode');
			expect(result).toBeUndefined();
		});
		it('should skip parent nodes without runData', () => {
			const workflow = (0, jest_mock_extended_1.mock)({
				getParentNodes: jest.fn().mockReturnValue(['Form1', 'Form2', 'Form3']),
				nodes: {
					LastNode: {
						disabled: undefined,
						type: 'other-node-type',
						parameters: {},
					},
					Form1: {
						disabled: undefined,
						type: n8n_workflow_1.FORM_NODE_TYPE,
						parameters: {
							operation: 'completion',
						},
					},
					Form2: {
						disabled: undefined,
						type: n8n_workflow_1.FORM_NODE_TYPE,
						parameters: {
							operation: 'completion',
						},
					},
					Form3: {
						disabled: undefined,
						type: n8n_workflow_1.FORM_NODE_TYPE,
						parameters: {
							operation: 'completion',
						},
					},
				},
			});
			const runData = {
				Form2: [],
			};
			const result = waitingForms.findCompletionPage(workflow, runData, 'LastNode');
			expect(result).toBe('Form2');
		});
		it('should return status of execution if suffix is WAITING_FORMS_EXECUTION_STATUS', async () => {
			const execution = (0, jest_mock_extended_1.mock)({
				status: 'success',
			});
			executionRepository.findSingleExecution.mockResolvedValue(execution);
			const req = (0, jest_mock_extended_1.mock)({
				headers: {},
				params: {
					path: '123',
					suffix: n8n_workflow_1.WAITING_FORMS_EXECUTION_STATUS,
				},
			});
			const res = (0, jest_mock_extended_1.mock)();
			const result = await waitingForms.executeWebhook(req, res);
			expect(result).toEqual({ noWebhookResponse: true });
			expect(res.send).toHaveBeenCalledWith(execution.status);
		});
	});
});
//# sourceMappingURL=waiting-forms.test.js.map
