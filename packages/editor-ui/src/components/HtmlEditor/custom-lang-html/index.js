import { ContextTracker, ExternalTokenizer, LRParser } from '@lezer/lr';
import { styleTags, tags } from '@lezer/highlight';
import { parseMixed } from '@lezer/common';
import { cssLanguage, css } from '@codemirror/lang-css';
import { typescriptLanguage, jsxLanguage, tsxLanguage, javascriptLanguage, javascript } from '@codemirror/lang-javascript';
import { EditorView } from '@codemirror/view';
import { EditorSelection } from '@codemirror/state';
import { syntaxTree, LRLanguage, indentNodeProp, foldNodeProp, LanguageSupport } from '@codemirror/language';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const scriptText = 55,
  StartCloseScriptTag = 1,
  styleText = 56,
  StartCloseStyleTag = 2,
  textareaText = 57,
  StartCloseTextareaTag = 3,
  StartTag = 4,
  StartScriptTag = 5,
  StartStyleTag = 6,
  StartTextareaTag = 7,
  StartSelfClosingTag = 8,
  StartCloseTag = 9,
  NoMatchStartCloseTag = 10,
  MismatchedStartCloseTag = 11,
  missingCloseTag = 58,
  IncompleteCloseTag = 12,
  commentContent$1 = 59,
  Element = 19,
  TagName = 21,
  Attribute = 22,
  AttributeName = 23,
  AttributeValue = 25,
  UnquotedAttributeValue = 26,
  ScriptText = 28,
  StyleText = 31,
  TextareaText = 34,
  OpenTag = 36,
  CloseTag = 37,
  Dialect_noMatch = 0;

/* Hand-written tokenizers for HTML. */

const selfClosers = {
  area: true, base: true, br: true, col: true, command: true,
  embed: true, frame: true, hr: true, img: true, input: true,
  keygen: true, link: true, meta: true, param: true, source: true,
  track: true, wbr: true, menuitem: true
};

const implicitlyClosed = {
  dd: true, li: true, optgroup: true, option: true, p: true,
  rp: true, rt: true, tbody: true, td: true, tfoot: true,
  th: true, tr: true
};

const closeOnOpen = {
  dd: {dd: true, dt: true},
  dt: {dd: true, dt: true},
  li: {li: true},
  option: {option: true, optgroup: true},
  optgroup: {optgroup: true},
  p: {
    address: true, article: true, aside: true, blockquote: true, dir: true,
    div: true, dl: true, fieldset: true, footer: true, form: true,
    h1: true, h2: true, h3: true, h4: true, h5: true, h6: true,
    header: true, hgroup: true, hr: true, menu: true, nav: true, ol: true,
    p: true, pre: true, section: true, table: true, ul: true
  },
  rp: {rp: true, rt: true},
  rt: {rp: true, rt: true},
  tbody: {tbody: true, tfoot: true},
  td: {td: true, th: true},
  tfoot: {tbody: true},
  th: {td: true, th: true},
  thead: {tbody: true, tfoot: true},
  tr: {tr: true}
};

function nameChar(ch) {
  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161
}

function isSpace(ch) {
  return ch == 9 || ch == 10 || ch == 13 || ch == 32
}

let cachedName = null, cachedInput = null, cachedPos = 0;
function tagNameAfter(input, offset) {
  let pos = input.pos + offset;
  if (cachedPos == pos && cachedInput == input) return cachedName
  let next = input.peek(offset);
  while (isSpace(next)) next = input.peek(++offset);
  let name = "";
  for (;;) {
    if (!nameChar(next)) break
    name += String.fromCharCode(next);
    next = input.peek(++offset);
  }
  // Undefined to signal there's a <? or <!, null for just missing
  cachedInput = input; cachedPos = pos;
  return cachedName = name ? name.toLowerCase() : next == question || next == bang ? undefined : null
}

const lessThan = 60, greaterThan = 62, slash = 47, question = 63, bang = 33, dash = 45;

function ElementContext(name, parent) {
  this.name = name;
  this.parent = parent;
  this.hash = parent ? parent.hash : 0;
  for (let i = 0; i < name.length; i++) this.hash += (this.hash << 4) + name.charCodeAt(i) + (name.charCodeAt(i) << 8);
}

const startTagTerms = [StartTag, StartSelfClosingTag, StartScriptTag, StartStyleTag, StartTextareaTag];

const elementContext = /*@__PURE__*/new ContextTracker({
  start: null,
  shift(context, term, stack, input) {
    return startTagTerms.indexOf(term) > -1 ? new ElementContext(tagNameAfter(input, 1) || "", context) : context
  },
  reduce(context, term) {
    return term == Element && context ? context.parent : context
  },
  reuse(context, node, stack, input) {
    let type = node.type.id;
    return type == StartTag || type == OpenTag
      ? new ElementContext(tagNameAfter(input, 1) || "", context) : context
  },
  hash(context) { return context ? context.hash : 0 },
  strict: false
});

const tagStart = /*@__PURE__*/new ExternalTokenizer((input, stack) => {
  if (input.next != lessThan) {
    // End of file, close any open tags
    if (input.next < 0 && stack.context) input.acceptToken(missingCloseTag);
    return
  }
  input.advance();
  let close = input.next == slash;
  if (close) input.advance();
  let name = tagNameAfter(input, 0);
  if (name === undefined) return
  if (!name) return input.acceptToken(close ? IncompleteCloseTag : StartTag)

  let parent = stack.context ? stack.context.name : null;
  if (close) {
    if (name == parent) return input.acceptToken(StartCloseTag)
    if (parent && implicitlyClosed[parent]) return input.acceptToken(missingCloseTag, -2)
    if (stack.dialectEnabled(Dialect_noMatch)) return input.acceptToken(NoMatchStartCloseTag)
    for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name) return
    input.acceptToken(MismatchedStartCloseTag);
  } else {
    if (name == "script") return input.acceptToken(StartScriptTag)
    if (name == "style") return input.acceptToken(StartStyleTag)
    if (name == "textarea") return input.acceptToken(StartTextareaTag)
    if (selfClosers.hasOwnProperty(name)) return input.acceptToken(StartSelfClosingTag)
    if (parent && closeOnOpen[parent] && closeOnOpen[parent][name]) input.acceptToken(missingCloseTag, -1);
    else input.acceptToken(StartTag);
  }
}, {contextual: true});

const commentContent = /*@__PURE__*/new ExternalTokenizer(input => {
  for (let dashes = 0, i = 0;; i++) {
    if (input.next < 0) {
      if (i) input.acceptToken(commentContent$1);
      break
    }
    if (input.next == dash) {
      dashes++;
    } else if (input.next == greaterThan && dashes >= 2) {
      if (i > 3) input.acceptToken(commentContent$1, -2);
      break
    } else {
      dashes = 0;
    }
    input.advance();
  }
});

function contentTokenizer(tag, textToken, endToken) {
  let lastState = 2 + tag.length;
  return new ExternalTokenizer(input => {
    // state means:
    // - 0 nothing matched
    // - 1 '<' matched
    // - 2 '</' + possibly whitespace matched
    // - 3-(1+tag.length) part of the tag matched
    // - lastState whole tag + possibly whitespace matched
    for (let state = 0, matchedLen = 0, i = 0;; i++) {
      if (input.next < 0) {
        if (i) input.acceptToken(textToken);
        break
      }
      if (state == 0 && input.next == lessThan ||
          state == 1 && input.next == slash ||
          state >= 2 && state < lastState && input.next == tag.charCodeAt(state - 2)) {
        state++;
        matchedLen++;
      } else if ((state == 2 || state == lastState) && isSpace(input.next)) {
        matchedLen++;
      } else if (state == lastState && input.next == greaterThan) {
        if (i > matchedLen)
          input.acceptToken(textToken, -matchedLen);
        else
          input.acceptToken(endToken, -(matchedLen - 2));
        break
      } else if ((input.next == 10 /* '\n' */ || input.next == 13 /* '\r' */) && i) {
        input.acceptToken(textToken, 1);
        break
      } else {
        state = matchedLen = 0;
      }
      input.advance();
    }
  })
}

const scriptTokens = /*@__PURE__*/contentTokenizer("script", scriptText, StartCloseScriptTag);

const styleTokens = /*@__PURE__*/contentTokenizer("style", styleText, StartCloseStyleTag);

const textareaTokens = /*@__PURE__*/contentTokenizer("textarea", textareaText, StartCloseTextareaTag);

const htmlHighlighting = /*@__PURE__*/styleTags({
  "Text RawText": tags.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": tags.angleBracket,
  TagName: tags.tagName,
  "MismatchedCloseTag/TagName": [tags.tagName,  tags.invalid],
  AttributeName: tags.attributeName,
  "AttributeValue UnquotedAttributeValue": tags.attributeValue,
  Is: tags.definitionOperator,
  "EntityReference CharacterReference": tags.character,
  Comment: tags.blockComment,
  ProcessingInst: tags.processingInstruction,
  DoctypeDecl: tags.documentMeta
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = /*@__PURE__*/LRParser.deserialize({
  version: 14,
  states: ",xOVOxOOO!ZQ!bO'#CpO!`Q!bO'#CzO!eQ!bO'#C}O!jQ!bO'#DQO!oQ!bO'#DSO!tOXO'#CoO#POYO'#CoO#[O[O'#CoO$kOxO'#CoOOOW'#Co'#CoO$rO!rO'#DUO$zQ!bO'#DWO%PQ!bO'#DXOOOW'#Dl'#DlOOOW'#DZ'#DZQVOxOOO%UQ#tO,59[O%^Q#tO,59fO%fQ#tO,59iO%nQ#tO,59lO%yQ#tO,59nOOOX'#D_'#D_O&ROXO'#CxO&^OXO,59ZOOOY'#D`'#D`O&fOYO'#C{O&qOYO,59ZOOO['#Da'#DaO&yO[O'#DOO'UO[O,59ZOOOW'#Db'#DbO'^OxO,59ZO'eQ!bO'#DROOOW,59Z,59ZOOO`'#Dc'#DcO'jO!rO,59pOOOW,59p,59pO'rQ!bO,59rO'wQ!bO,59sOOOW-E7X-E7XO'|Q#tO'#CrOOQO'#D['#D[O([Q#tO1G.vOOOX1G.v1G.vO(dQ#tO1G/QOOOY1G/Q1G/QO(lQ#tO1G/TOOO[1G/T1G/TO(tQ#tO1G/WOOOW1G/W1G/WOOOW1G/Y1G/YO)PQ#tO1G/YOOOX-E7]-E7]O)XQ!bO'#CyOOOW1G.u1G.uOOOY-E7^-E7^O)^Q!bO'#C|OOO[-E7_-E7_O)cQ!bO'#DPOOOW-E7`-E7`O)hQ!bO,59mOOO`-E7a-E7aOOOW1G/[1G/[OOOW1G/^1G/^OOOW1G/_1G/_O)mQ&jO,59^OOQO-E7Y-E7YOOOX7+$b7+$bOOOY7+$l7+$lOOO[7+$o7+$oOOOW7+$r7+$rOOOW7+$t7+$tO)xQ!bO,59eO)}Q!bO,59hO*SQ!bO,59kOOOW1G/X1G/XO*XO,UO'#CuO*jO7[O'#CuOOQO1G.x1G.xOOOW1G/P1G/POOOW1G/S1G/SOOOW1G/V1G/VOOOO'#D]'#D]O*{O,UO,59aOOQO,59a,59aOOOO'#D^'#D^O+^O7[O,59aOOOO-E7Z-E7ZOOQO1G.{1G.{OOOO-E7[-E7[",
  stateData: "+}~O!_OS~OSSOTPOUQOVROWTOY]OZ[O[^O^^O_^O`^Oa^Ob^Oy^O|_O!eZO~OeaO~OebO~OecO~OedO~OeeO~O!XfOPlP![lP~O!YiOQoP![oP~O!ZlORrP![rP~OSSOTPOUQOVROWTOXqOY]OZ[O[^O^^O_^O`^Oa^Ob^Oy^O!eZO~O![rO~P#gO!]sO!fuO~OevO~OewO~OgyOk|O~OgyOk!OO~OgyOk!QO~OgyOk!SOw!TO~OgyOk!TO~O!XfOPlX![lX~OP!WO![!XO~O!YiOQoX![oX~OQ!ZO![!XO~O!ZlORrX![rX~OR!]O![!XO~O![!XO~P#gOe!_O~O!]sO!f!aO~Ok!bO~Ok!cO~Oh!dOgfXkfXwfX~OgyOk!fO~OgyOk!gO~OgyOk!hO~OgyOk!iOw!jO~OgyOk!jO~Oe!kO~Oe!lO~Oe!mO~Ok!nO~Oj!qO!a!oO!c!pO~Ok!rO~Ok!sO~Ok!tO~O`!uOa!uOb!uO!a!wO!b!uO~O`!xOa!xOb!xO!c!wO!d!xO~O`!uOa!uOb!uO!a!{O!b!uO~O`!xOa!xOb!xO!c!{O!d!xO~Ow~_^w!ey|ak`b`~",
  goto: "%q!aPPPPPPPPPPPPPPPPPPP!b!hP!nPP!zPP!}#Q#T#Z#^#a#g#j#m#s#yP!bP!b!bP$P$V$m$s$y%P%V%]%cPPPPPPPP%iX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "âš  StartCloseTag StartCloseTag StartCloseTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text Resolvable EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag SelfClosingEndTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 68,
  context: elementContext,
  nodeProps: [
    ["closedBy", -10,1,2,3,5,6,7,8,9,10,11,"EndTag",4,"EndTag SelfClosingEndTag",-4,20,30,33,36,"CloseTag"],
    ["group", -10,12,15,16,17,18,19,40,41,42,43,"Entity",14,"Entity TextContent",-3,28,31,34,"TextContent Entity"],
    ["openedBy", 27,"StartTag StartCloseTag",-4,29,32,35,37,"OpenTag",39,"StartTag"]
  ],
  propSources: [htmlHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "&(b!aR!ZOX$tXY3aYZ3aZ[$t[]&b]^3a^p$tpq3aqr4trsBjsv4tvwC`wx!*Tx}4t}!O!*|!O!P4t!P!Q!0_!Q![4t![!]!3O!]!^4t!^!_!7Z!_!`#5r!`!a#6p!a!c4t!c!}!3O!}#R4t#R#S!3O#S#T:r#T#o!3O#o#p#7n#p#s4t#s$f$t$f%W4t%W%o!3O%o%p4t%p&a!3O&a&b4t&b1p!3O1p4U4t4U4d!3O4d4e4t4e$IS!3O$IS$I`4t$I`$Ib!3O$Ib$Kh4t$Kh%#t!3O%#t&/x4t&/x&Et!3O&Et&FV4t&FV;'S!3O;'S;:j!7T;:j;=`Bd<%l?&r4t?&r?Ah!3O?Ah?BY$t?BY?Mn!3O?MnO$t!Z%PejW!b`!dp^POX$tXZ&bZ[$t[^&b^p$tpq&bqr$trs'^sv$tvw/Vwx*yx!^$t!^!_-]!_!a&b!a#S$t#S#T&b#T#o$t#o#p0Q#p;'S$t;'S;=`3Z<%lO$t!R&kZ!b`!dp^POr&brs'^sv&bwx*yx!^&b!^!_-]!_#o&b#o#p.P#p;'S&b;'S;=`/P<%lO&bq'eX!dp^POv'^wx(Qx!^'^!^!_)d!_#o'^#o#p){#p;'S'^;'S;=`*s<%lO'^P(VV^POv(Qw!^(Q!_#o(Q#o#p(l#p;'S(Q;'S;=`)X<%lO(QP(oWOv(Qw!^(Q!_#o(Q#p;'S(Q;'S;=`)X<%l~(Q~O(Q~~)_P)[P;=`<%l(QP)dO^Pp)iS!dpOv)dx;'S)d;'S;=`)u<%lO)dp)xP;=`<%l)dq*QZ!dpOv'^wx(Qx!^'^!^!_)d!_#o'^#o#p)d#p;'S'^;'S;=`*s<%l~'^~O'^~~)_q*vP;=`<%l'^a+QY!b`^POr*yrs(Qsv*yw!^*y!^!_+p!_#o*y#o#p,[#p;'S*y;'S;=`-V<%lO*y`+uT!b`Or+psv+pw;'S+p;'S;=`,U<%lO+p`,XP;=`<%l+pa,a[!b`Or*yrs(Qsv*yw!^*y!^!_+p!_#o*y#o#p+p#p;'S*y;'S;=`-V<%l~*y~O*y~~)_a-YP;=`<%l*y!Q-dV!b`!dpOr-]rs)dsv-]wx+px;'S-];'S;=`-y<%lO-]!Q-|P;=`<%l-]!R.W]!b`!dpOr&brs'^sv&bwx*yx!^&b!^!_-]!_#o&b#o#p-]#p;'S&b;'S;=`/P<%l~&b~O&b~~)_!R/SP;=`<%l&bW/[YjWOX/VZ[/V^p/Vqr/Vsw/Vx!^/V!a#S/V#T;'S/V;'S;=`/z<%lO/VW/}P;=`<%l/V!Z0ZgjW!b`!dpOX$tXZ&bZ[$t[^&b^p$tpq&bqr$trs'^sv$tvw/Vwx*yx!^$t!^!_-]!_!a&b!a#S$t#S#T&b#T#o$t#o#p1r#p;'S$t;'S;=`3Z<%l~$t~O$t~~)_!Y1{bjW!b`!dpOX1rXZ-]Z[1r[^-]^p1rpq-]qr1rrs)dsv1rvw/Vwx+px!^1r!^!a-]!a#S1r#S#T-]#T;'S1r;'S;=`3T<%lO1r!Y3WP;=`<%l1r!Z3^P;=`<%l$t!a3lb!b`!dp!_^^POX&bXY3aYZ3aZ]&b]^3a^p&bpq3aqr&brs'^sv&bwx*yx!^&b!^!_-]!_#o&b#o#p.P#p;'S&b;'S;=`/P<%lO&b!_5RlgSjW!b`!dp^POX$tXZ&bZ[$t[^&b^p$tpq&bqr4trs'^sv4tvw6ywx*yx!P4t!P!Q$t!Q!^4t!^!_9Z!_!a&b!a#S4t#S#T:r#T#o4t#o#p>W#p#s4t#s$f$t$f;'S4t;'S;=`Bd<%l?Ah4t?Ah?BY$t?BY?Mn4t?MnO$t[7QcgSjWOX/VZ[/V^p/Vqr6ysw6yx!P6y!P!Q/V!Q!^6y!^!_8]!a#S6y#S#T8]#T#s6y#s$f/V$f;'S6y;'S;=`9T<%l?Ah6y?Ah?BY/V?BY?Mn6y?MnO/VS8bXgSqr8]sw8]x!P8]!Q!_8]!a#s8]$f;'S8];'S;=`8}<%l?Ah8]?BY?Mn8]S9QP;=`<%l8][9WP;=`<%l6y!U9dbgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!U:oP;=`<%l9Z!V:}egS!b`!dp^POq&bqr:rrs'^sv:rvw8]wx*yx!P:r!P!Q&b!Q!^:r!^!_9Z!_!a&b!a#o:r#o#p<`#p#s:r#s$f&b$f;'S:r;'S;=`>Q<%l?Ah:r?Ah?BY&b?BY?Mn:r?MnO&b!V<iggS!b`!dpOq&bqr:rrs'^sv:rvw8]wx*yx!P:r!P!Q&b!Q!^:r!^!_9Z!_!a&b!a#o:r#o#p9Z#p#s:r#s$f&b$f;'S:r;'S;=`>Q<%l?Ah:r?Ah?BY&b?BY?Mn:r?Mn~&b~O&b~~)_!V>TP;=`<%l:r!_>cngSjW!b`!dpOX$tXZ&bZ[$t[^&b^p$tpq&bqr4trs'^sv4tvw6ywx*yx!P4t!P!Q$t!Q!^4t!^!_9Z!_!a&b!a#S4t#S#T:r#T#o4t#o#p@a#p#s4t#s$f$t$f;'S4t;'S;=`Bd<%l?Ah4t?Ah?BY$t?BY?Mn4t?Mn~$t~O$t~~)_!^@ljgSjW!b`!dpOX1rXZ-]Z[1r[^-]^p1rpq-]qr@ars)dsv@avw6ywx+px!P@a!P!Q1r!Q!^@a!^!_9Z!_!a-]!a#S@a#S#T9Z#T#s@a#s$f1r$f;'S@a;'S;=`B^<%l?Ah@a?Ah?BY1r?BY?Mn@a?MnO1r!^BaP;=`<%l@a!_BgP;=`<%l4t!ZBsX!ah!dp^POv'^wx(Qx!^'^!^!_)d!_#o'^#o#p){#p;'S'^;'S;=`*s<%lO'^!_CijgSjWb!ROXEZXZFhZ[EZ[^Fh^pEZqrHYrsFhstMztwHYwxFhx!PHY!P!QEZ!Q!]HY!]!^6y!^!_Kg!_!aFh!a#SHY#S#TKg#T#sHY#s$fEZ$f;'SHY;'S;=`Mt<%l?AhHY?Ah?BYEZ?BY?MnHY?MnOEZ!ZE`bjWOXEZXZFhZ[EZ[^Fh^pEZqrEZrsFhst/VtwEZwxFhx!]EZ!]!^G]!^!aFh!a#SEZ#S#TFh#T;'SEZ;'S;=`HS<%lOEZ!RFkVOpFhqsFht!]Fh!]!^GQ!^;'SFh;'S;=`GV<%lOFh!RGVO`!R!RGYP;=`<%lFh!ZGdYjW`!ROX/VZ[/V^p/Vqr/Vsw/Vx!^/V!a#S/V#T;'S/V;'S;=`/z<%lO/V!ZHVP;=`<%lEZ!_HajgSjWOXEZXZFhZ[EZ[^Fh^pEZqrHYrsFhst6ytwHYwxFhx!PHY!P!QEZ!Q!]HY!]!^JR!^!_Kg!_!aFh!a#SHY#S#TKg#T#sHY#s$fEZ$f;'SHY;'S;=`Mt<%l?AhHY?Ah?BYEZ?BY?MnHY?MnOEZ!_J[cgSjW`!ROX/VZ[/V^p/Vqr6ysw6yx!P6y!P!Q/V!Q!^6y!^!_8]!a#S6y#S#T8]#T#s6y#s$f/V$f;'S6y;'S;=`9T<%l?Ah6y?Ah?BY/V?BY?Mn6y?MnO/V!VKldgSOpFhqrKgrsFhst8]twKgwxFhx!PKg!P!QFh!Q!]Kg!]!^Lz!^!_Kg!_!aFh!a#sKg#s$fFh$f;'SKg;'S;=`Mn<%l?AhKg?Ah?BYFh?BY?MnKg?MnOFh!VMRXgS`!Rqr8]sw8]x!P8]!Q!_8]!a#s8]$f;'S8];'S;=`8}<%l?Ah8]?BY?Mn8]!VMqP;=`<%lKg!_MwP;=`<%lHY!_NRigSjWOX! pXZ!!zZ[! p[^!!z^p! pqr!$irs!!zsw!$iwx!!zx!P!$i!P!Q! p!Q!]!$i!]!^6y!^!_!'s!_!a!!z!a#S!$i#S#T!'s#T#s!$i#s$f! p$f;'S!$i;'S;=`!)}<%l?Ah!$i?Ah?BY! p?BY?Mn!$i?MnO! p!Z! uajWOX! pXZ!!zZ[! p[^!!z^p! pqr! prs!!zsw! pwx!!zx!]! p!]!^!#l!^!a!!z!a#S! p#S#T!!z#T;'S! p;'S;=`!$c<%lO! p!R!!}UOp!!zq!]!!z!]!^!#a!^;'S!!z;'S;=`!#f<%lO!!z!R!#fOa!R!R!#iP;=`<%l!!z!Z!#sYjWa!ROX/VZ[/V^p/Vqr/Vsw/Vx!^/V!a#S/V#T;'S/V;'S;=`/z<%lO/V!Z!$fP;=`<%l! p!_!$pigSjWOX! pXZ!!zZ[! p[^!!z^p! pqr!$irs!!zsw!$iwx!!zx!P!$i!P!Q! p!Q!]!$i!]!^!&_!^!_!'s!_!a!!z!a#S!$i#S#T!'s#T#s!$i#s$f! p$f;'S!$i;'S;=`!)}<%l?Ah!$i?Ah?BY! p?BY?Mn!$i?MnO! p!_!&hcgSjWa!ROX/VZ[/V^p/Vqr6ysw6yx!P6y!P!Q/V!Q!^6y!^!_8]!a#S6y#S#T8]#T#s6y#s$f/V$f;'S6y;'S;=`9T<%l?Ah6y?Ah?BY/V?BY?Mn6y?MnO/V!V!'xcgSOp!!zqr!'srs!!zsw!'swx!!zx!P!'s!P!Q!!z!Q!]!'s!]!^!)T!^!_!'s!_!a!!z!a#s!'s#s$f!!z$f;'S!'s;'S;=`!)w<%l?Ah!'s?Ah?BY!!z?BY?Mn!'s?MnO!!z!V!)[XgSa!Rqr8]sw8]x!P8]!Q!_8]!a#s8]$f;'S8];'S;=`8}<%l?Ah8]?BY?Mn8]!V!)zP;=`<%l!'s!_!*QP;=`<%l!$i!Z!*^Y!cx!b`^POr*yrs(Qsv*yw!^*y!^!_+p!_#o*y#o#p,[#p;'S*y;'S;=`-V<%lO*y!a!+ZngSjW!b`!dp^POX$tXZ&bZ[$t[^&b^p$tpq&bqr4trs'^sv4tvw6ywx*yx}4t}!O!-X!O!P4t!P!Q$t!Q!^4t!^!_9Z!_!a&b!a#S4t#S#T:r#T#o4t#o#p>W#p#s4t#s$f$t$f;'S4t;'S;=`Bd<%l?Ah4t?Ah?BY$t?BY?Mn4t?MnO$t!a!-fmgSjW!b`!dp^POX$tXZ&bZ[$t[^&b^p$tpq&bqr4trs'^sv4tvw6ywx*yx!P4t!P!Q$t!Q!^4t!^!_9Z!_!`&b!`!a!/a!a#S4t#S#T:r#T#o4t#o#p>W#p#s4t#s$f$t$f;'S4t;'S;=`Bd<%l?Ah4t?Ah?BY$t?BY?Mn4t?MnO$t!T!/lZ!b`!dp!fQ^POr&brs'^sv&bwx*yx!^&b!^!_-]!_#o&b#o#p.P#p;'S&b;'S;=`/P<%lO&b!a!0jfjW!b`!dp^POX$tXZ&bZ[$t[^&b^p$tpq&bqr$trs'^sv$tvw/Vwx*yx!^$t!^!_-]!_!`&b!`!a!2O!a#S$t#S#T&b#T#o$t#o#p0Q#p;'S$t;'S;=`3Z<%lO$t!X!2]Z!b`!dp^PwSkUOr&brs'^sv&bwx*yx!^&b!^!_-]!_#o&b#o#p.P#p;'S&b;'S;=`/P<%lO&b!a!3_![gSeQjW!b`!dp^POX$tXZ&bZ[$t[^&b^p$tpq&bqr4trs'^sv4tvw6ywx*yx}4t}!O!3O!O!P!3O!P!Q$t!Q![!3O![!]!3O!]!^4t!^!_9Z!_!a&b!a!c4t!c!}!3O!}#R4t#R#S!3O#S#T:r#T#o!3O#o#p>W#p#s4t#s$f$t$f$}4t$}%O!3O%O%W4t%W%o!3O%o%p4t%p&a!3O&a&b4t&b1p!3O1p4U!3O4U4d!3O4d4e4t4e$IS!3O$IS$I`4t$I`$Ib!3O$Ib$Je4t$Je$Jg!3O$Jg$Kh4t$Kh%#t!3O%#t&/x4t&/x&Et!3O&Et&FV4t&FV;'S!3O;'S;:j!7T;:j;=`Bd<%l?&r4t?&r?Ah!3O?Ah?BY$t?BY?Mn!3O?MnO$t!a!7WP;=`<%l!3O!V!7dcgS!b`!dpOq-]qr!8ors)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a!b#(|!b#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!8xhgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px}9Z}!O!:d!O!P9Z!P!Q-]!Q!_9Z!_!a-]!a!f9Z!f!g!=`!g#W9Z#W#X!M|#X#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!:mdgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px}9Z}!O!;{!O!P9Z!P!Q-]!Q!_9Z!_!a-]!a#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!<WbgS!b`!dp!ePOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!=idgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a!q9Z!q!r!>w!r#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!?QdgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a!e9Z!e!f!@`!f#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!@idgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a!v9Z!v!w!Aw!w#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!BQdgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a!{9Z!{!|!C`!|#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!CidgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a!r9Z!r!s!Dw!s#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!EQdgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a!g9Z!g!h!F`!h#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!FicgS!b`!dpOq!Gtqr!F`rs!Hksv!F`vw!Lcwx!J_x!P!F`!P!Q!Gt!Q!_!F`!_!`!Gt!`!a!Km!a#s!F`#s$f!Gt$f;'S!F`;'S;=`!Mv<%l?Ah!F`?Ah?BY!Gt?BY?Mn!F`?MnO!Gt!R!G{Y!b`!dpOr!Gtrs!Hksv!Gtvw!IVwx!J_x!`!Gt!`!a!Km!a;'S!Gt;'S;=`!L]<%lO!Gtq!HpV!dpOv!Hkvx!IVx!`!Hk!`!a!It!a;'S!Hk;'S;=`!JX<%lO!HkP!IYTO!`!IV!`!a!Ii!a;'S!IV;'S;=`!In<%lO!IVP!InO|PP!IqP;=`<%l!IVq!I{S!dp|POv)dx;'S)d;'S;=`)u<%lO)dq!J[P;=`<%l!Hka!JdX!b`Or!J_rs!IVsv!J_vw!IVw!`!J_!`!a!KP!a;'S!J_;'S;=`!Kg<%lO!J_a!KWT!b`|POr+psv+pw;'S+p;'S;=`,U<%lO+pa!KjP;=`<%l!J_!R!KvV!b`!dp|POr-]rs)dsv-]wx+px;'S-];'S;=`-y<%lO-]!R!L`P;=`<%l!GtT!LhbgSOq!IVqr!Lcrs!IVsw!Lcwx!IVx!P!Lc!P!Q!IV!Q!_!Lc!_!`!IV!`!a!Ii!a#s!Lc#s$f!IV$f;'S!Lc;'S;=`!Mp<%l?Ah!Lc?Ah?BY!IV?BY?Mn!Lc?MnO!IVT!MsP;=`<%l!Lc!V!MyP;=`<%l!F`!V!NVdgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#c9Z#c#d# e#d#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V# ndgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#V9Z#V#W#!|#W#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V##VdgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#h9Z#h#i#$e#i#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V#$ndgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#m9Z#m#n#%|#n#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V#&VdgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#d9Z#d#e#'e#e#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V#'ndgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#X9Z#X#Y!F`#Y#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V#)VcgS!b`!dpOq#*bqr#(|rs#+Xsv#(|vw#1fwx#-yx!P#(|!P!Q#*b!Q!_#(|!_!a#*b!a!b#4W!b#s#(|#s$f#*b$f;'S#(|;'S;=`#5l<%l?Ah#(|?Ah?BY#*b?BY?Mn#(|?MnO#*b!R#*iY!b`!dpOr#*brs#+Xsv#*bvw#+swx#-yx!a#*b!a!b#/y!b;'S#*b;'S;=`#1`<%lO#*bq#+^V!dpOv#+Xvx#+sx!a#+X!a!b#,t!b;'S#+X;'S;=`#-s<%lO#+XP#+vTO!a#+s!a!b#,V!b;'S#+s;'S;=`#,n<%lO#+sP#,YTO!`#+s!`!a#,i!a;'S#+s;'S;=`#,n<%lO#+sP#,nOyPP#,qP;=`<%l#+sq#,yV!dpOv#+Xvx#+sx!`#+X!`!a#-`!a;'S#+X;'S;=`#-s<%lO#+Xq#-gS!dpyPOv)dx;'S)d;'S;=`)u<%lO)dq#-vP;=`<%l#+Xa#.OX!b`Or#-yrs#+ssv#-yvw#+sw!a#-y!a!b#.k!b;'S#-y;'S;=`#/s<%lO#-ya#.pX!b`Or#-yrs#+ssv#-yvw#+sw!`#-y!`!a#/]!a;'S#-y;'S;=`#/s<%lO#-ya#/dT!b`yPOr+psv+pw;'S+p;'S;=`,U<%lO+pa#/vP;=`<%l#-y!R#0QY!b`!dpOr#*brs#+Xsv#*bvw#+swx#-yx!`#*b!`!a#0p!a;'S#*b;'S;=`#1`<%lO#*b!R#0yV!b`!dpyPOr-]rs)dsv-]wx+px;'S-];'S;=`-y<%lO-]!R#1cP;=`<%l#*bT#1kbgSOq#+sqr#1frs#+ssw#1fwx#+sx!P#1f!P!Q#+s!Q!_#1f!_!a#+s!a!b#2s!b#s#1f#s$f#+s$f;'S#1f;'S;=`#4Q<%l?Ah#1f?Ah?BY#+s?BY?Mn#1f?MnO#+sT#2xbgSOq#+sqr#1frs#+ssw#1fwx#+sx!P#1f!P!Q#+s!Q!_#1f!_!`#+s!`!a#,i!a#s#1f#s$f#+s$f;'S#1f;'S;=`#4Q<%l?Ah#1f?Ah?BY#+s?BY?Mn#1f?MnO#+sT#4TP;=`<%l#1f!V#4acgS!b`!dpOq#*bqr#(|rs#+Xsv#(|vw#1fwx#-yx!P#(|!P!Q#*b!Q!_#(|!_!`#*b!`!a#0p!a#s#(|#s$f#*b$f;'S#(|;'S;=`#5l<%l?Ah#(|?Ah?BY#*b?BY?Mn#(|?MnO#*b!V#5oP;=`<%l#(|!V#5}ZhS!b`!dp^POr&brs'^sv&bwx*yx!^&b!^!_-]!_#o&b#o#p.P#p;'S&b;'S;=`/P<%lO&b!X#6{Z!b`!dp^PkUOr&brs'^sv&bwx*yx!^&b!^!_-]!_#o&b#o#p.P#p;'S&b;'S;=`/P<%lO&b!_#7yngSjW!b`!dpOX$tXZ&bZ[$t[^&b^p$tpq&bqr4trs'^sv4tvw6ywx*yx!P4t!P!Q$t!Q!^4t!^!_9Z!_!a&b!a#S4t#S#T:r#T#o4t#o#p#9w#p#s4t#s$f$t$f;'S4t;'S;=`Bd<%l?Ah4t?Ah?BY$t?BY?Mn4t?Mn~$t~O$t~~)_!_#:S!SgSjW!b`!dpOX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#9wrs#CTsv#9wvw$MTwx$$`x!P#9w!P!Q#=`!Q![#9w![!^#9w!^!_%:{!_!a#@c!a!c#9w!c!}#9w!}#O#9w#O#P%IT#P#S#9w#S#T%:{#T#o#9w#o#q#9w#q#r&$Y#r#s#9w#s#y#=`#y#z#=`#z$f#=`$f$g#9w$gG|#9wG|#BY@a#BY#BZ#9w#BZ$IS@a$IS$I_#9w$I_$I|@a$I|$JO#9w$JO$JT@a$JT$JU#9w$JU$KV@a$KV$KW#9w$KW&FU@a&FU&FV#9w&FV;'S@a;'S;=`B^<%l?Ah@a?Ah?BY1r?BY?Mn@a?MnO1r!Z#=i|jW!b`!dpOX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#=`rs#CTsv#=`vw$5}wx$$`x!Q#=`!Q![#=`![!^#=`!^!a#@c!a!c#=`!c!}#=`!}#O#=`#O#P$Bb#P#S#=`#S#T#@c#T#o#=`#o#q#=`#q#r$JR#r#y#=`#y#z#=`#z$f#=`$f$g#=`$gG|#=`G|#BY1r#BY#BZ#=`#BZ$IS1r$IS$I_#=`$I_$I|1r$I|$JO#=`$JO$JT1r$JT$JU#=`$JU$KV1r$KV$KW#=`$KW&FU1r&FU&FV#=`&FV;'S1r;'S;=`3T<%lO1r!R#@jw!b`!dpOX#@cX^#@c^p#@cpq#@cqr#@crs#CTsv#@cvw#Ejwx$$`x!Q#@c!Q![#@c![!c#@c!c!}#@c!}#O#@c#O#P$.V#P#T#@c#T#o#@c#o#q#@c#q#r$4b#r#y#@c#y#z#@c#z$f#@c$f$g#@c$gG|#@cG|#BY-]#BY#BZ#@c#BZ$IS-]$IS$I_#@c$I_$I|-]$I|$JO#@c$JO$JT-]$JT$JU#@c$JU$KV-]$KV$KW#@c$KW&FU-]&FU&FV#@c&FV;'S-];'S;=`-y<%lO-]q#CYt!dpOX#CTX^#CT^p#CTpq#CTqv#CTvx#Ejx!Q#CT!Q![#CT![!c#CT!c!}#CT!}#O#CT#O#P#Kq#P#T#CT#T#o#CT#o#q#CT#q#r$#Z#r#y#CT#y#z#CT#z$f#CT$f$g#CT$gG|#CTG|#BY)d#BY#BZ#CT#BZ$IS)d$IS$I_#CT$I_$I|)d$I|$JO#CT$JO$JT)d$JT$JU#CT$JU$KV)d$KV$KW#CT$KW&FU)d&FU&FV#CT&FV;'S)d;'S;=`)u<%lO)dP#EmiOX#EjX^#Ej^p#Ejpq#Ejq!Q#Ej!Q![#Ej![!c#Ej!c!}#Ej!}#O#Ej#O#P#G[#P#T#Ej#T#o#Ej#o#q#Ej#q#r#KS#r#y#Ej#y#z#Ej#z$f#Ej$f$g#Ej$gG|#Ej#BY#BZ#Ej$IS$I_#Ej$I|$JO#Ej$JT$JU#Ej$KV$KW#Ej&FU&FV#EjP#G_iOX#EjX^#Ej^p#Ejpq#Ejq!Q#Ej!Q![#Ej![!c#Ej!c!}#Ej!}#O#Ej#O#P#G[#P#T#Ej#T#o#Ej#o#q#Ej#q#r#H|#r#y#Ej#y#z#Ej#z$f#Ej$f$g#Ej$gG|#Ej#BY#BZ#Ej$IS$I_#Ej$I|$JO#Ej$JT$JU#Ej$KV$KW#Ej&FU&FV#EjP#IPTO#q#Ej#q#r#I`#r;'S#Ej;'S;=`#Kk<%lO#EjP#Iei_POX#EjX^#Ej^p#Ejpq#Ejq!Q#Ej!Q![#Ej![!c#Ej!c!}#Ej!}#O#Ej#O#P#G[#P#T#Ej#T#o#Ej#o#q#Ej#q#r#KS#r#y#Ej#y#z#Ej#z$f#Ej$f$g#Ej$gG|#Ej#BY#BZ#Ej$IS$I_#Ej$I|$JO#Ej$JT$JU#Ej$KV$KW#Ej&FU&FV#EjP#KVTO#q#Ej#q#r#Kf#r;'S#Ej;'S;=`#Kk<%lO#EjP#KkO_PP#KnP;=`<%l#Ejq#Kvt!dpOX#CTX^#CT^p#CTpq#CTqv#CTvx#Ejx!Q#CT!Q![#CT![!c#CT!c!}#CT!}#O#CT#O#P#Kq#P#T#CT#T#o#CT#o#q#CT#q#r#NW#r#y#CT#y#z#CT#z$f#CT$f$g#CT$gG|#CTG|#BY)d#BY#BZ#CT#BZ$IS)d$IS$I_#CT$I_$I|)d$I|$JO#CT$JO$JT)d$JT$JU#CT$JU$KV)d$KV$KW#CT$KW&FU)d&FU&FV#CT&FV;'S)d;'S;=`)u<%lO)dq#N]V!dpOv#CTvx#Ejx#q#CT#q#r#Nr#r;'S#CT;'S;=`$$Y<%lO#CTq#Nyt!dp_POX#CTX^#CT^p#CTpq#CTqv#CTvx#Ejx!Q#CT!Q![#CT![!c#CT!c!}#CT!}#O#CT#O#P#Kq#P#T#CT#T#o#CT#o#q#CT#q#r$#Z#r#y#CT#y#z#CT#z$f#CT$f$g#CT$gG|#CTG|#BY)d#BY#BZ#CT#BZ$IS)d$IS$I_#CT$I_$I|)d$I|$JO#CT$JO$JT)d$JT$JU#CT$JU$KV)d$KV$KW#CT$KW&FU)d&FU&FV#CT&FV;'S)d;'S;=`)u<%lO)dq$#`V!dpOv#CTvx#Ejx#q#CT#q#r$#u#r;'S#CT;'S;=`$$Y<%lO#CTq$#|S!dp_POv)dx;'S)d;'S;=`)u<%lO)dq$$]P;=`<%l#CTa$$ev!b`OX$$`X^$$`^p$$`pq$$`qr$$`rs#Ejsv$$`vw#Ejw!Q$$`!Q![$$`![!c$$`!c!}$$`!}#O$$`#O#P$&{#P#T$$`#T#o$$`#o#q$$`#q#r$,w#r#y$$`#y#z$$`#z$f$$`$f$g$$`$gG|$$`G|#BY+p#BY#BZ$$`#BZ$IS+p$IS$I_$$`$I_$I|+p$I|$JO$$`$JO$JT+p$JT$JU$$`$JU$KV+p$KV$KW$$`$KW&FU+p&FU&FV$$`&FV;'S+p;'S;=`,U<%lO+pa$'Qv!b`OX$$`X^$$`^p$$`pq$$`qr$$`rs#Ejsv$$`vw#Ejw!Q$$`!Q![$$`![!c$$`!c!}$$`!}#O$$`#O#P$&{#P#T$$`#T#o$$`#o#q$$`#q#r$)h#r#y$$`#y#z$$`#z$f$$`$f$g$$`$gG|$$`G|#BY+p#BY#BZ$$`#BZ$IS+p$IS$I_$$`$I_$I|+p$I|$JO$$`$JO$JT+p$JT$JU$$`$JU$KV+p$KV$KW$$`$KW&FU+p&FU&FV$$`&FV;'S+p;'S;=`,U<%lO+pa$)mX!b`Or$$`rs#Ejsv$$`vw#Ejw#q$$`#q#r$*Y#r;'S$$`;'S;=`$.P<%lO$$`a$*av!b`_POX$$`X^$$`^p$$`pq$$`qr$$`rs#Ejsv$$`vw#Ejw!Q$$`!Q![$$`![!c$$`!c!}$$`!}#O$$`#O#P$&{#P#T$$`#T#o$$`#o#q$$`#q#r$,w#r#y$$`#y#z$$`#z$f$$`$f$g$$`$gG|$$`G|#BY+p#BY#BZ$$`#BZ$IS+p$IS$I_$$`$I_$I|+p$I|$JO$$`$JO$JT+p$JT$JU$$`$JU$KV+p$KV$KW$$`$KW&FU+p&FU&FV$$`&FV;'S+p;'S;=`,U<%lO+pa$,|X!b`Or$$`rs#Ejsv$$`vw#Ejw#q$$`#q#r$-i#r;'S$$`;'S;=`$.P<%lO$$`a$-pT!b`_POr+psv+pw;'S+p;'S;=`,U<%lO+pa$.SP;=`<%l$$`!R$.^w!b`!dpOX#@cX^#@c^p#@cpq#@cqr#@crs#CTsv#@cvw#Ejwx$$`x!Q#@c!Q![#@c![!c#@c!c!}#@c!}#O#@c#O#P$.V#P#T#@c#T#o#@c#o#q#@c#q#r$0w#r#y#@c#y#z#@c#z$f#@c$f$g#@c$gG|#@cG|#BY-]#BY#BZ#@c#BZ$IS-]$IS$I_#@c$I_$I|-]$I|$JO#@c$JO$JT-]$JT$JU#@c$JU$KV-]$KV$KW#@c$KW&FU-]&FU&FV#@c&FV;'S-];'S;=`-y<%lO-]!R$1OY!b`!dpOr#@crs#CTsv#@cvw#Ejwx$$`x#q#@c#q#r$1n#r;'S#@c;'S;=`$5w<%lO#@c!R$1ww!b`!dp_POX#@cX^#@c^p#@cpq#@cqr#@crs#CTsv#@cvw#Ejwx$$`x!Q#@c!Q![#@c![!c#@c!c!}#@c!}#O#@c#O#P$.V#P#T#@c#T#o#@c#o#q#@c#q#r$4b#r#y#@c#y#z#@c#z$f#@c$f$g#@c$gG|#@cG|#BY-]#BY#BZ#@c#BZ$IS-]$IS$I_#@c$I_$I|-]$I|$JO#@c$JO$JT-]$JT$JU#@c$JU$KV-]$KV$KW#@c$KW&FU-]&FU&FV#@c&FV;'S-];'S;=`-y<%lO-]!R$4iY!b`!dpOr#@crs#CTsv#@cvw#Ejwx$$`x#q#@c#q#r$5X#r;'S#@c;'S;=`$5w<%lO#@c!R$5bV!b`!dp_POr-]rs)dsv-]wx+px;'S-];'S;=`-y<%lO-]!R$5zP;=`<%l#@cX$6S{jWOX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$5}rs#Ejsw$5}wx#Ejx!Q$5}!Q![$5}![!^$5}!^!a#Ej!a!c$5}!c!}$5}!}#O$5}#O#P$8y#P#S$5}#S#T#Ej#T#o$5}#o#q$5}#q#r$@T#r#y$5}#y#z$5}#z$f$5}$f$g$5}$gG|$5}G|#BY/V#BY#BZ$5}#BZ$IS/V$IS$I_$5}$I_$I|/V$I|$JO$5}$JO$JT/V$JT$JU$5}$JU$KV/V$KV$KW$5}$KW&FU/V&FU&FV$5}&FV;'S/V;'S;=`/z<%lO/VX$9O{jWOX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$5}rs#Ejsw$5}wx#Ejx!Q$5}!Q![$5}![!^$5}!^!a#Ej!a!c$5}!c!}$5}!}#O$5}#O#P$8y#P#S$5}#S#T#Ej#T#o$5}#o#q$5}#q#r$;u#r#y$5}#y#z$5}#z$f$5}$f$g$5}$gG|$5}G|#BY/V#BY#BZ$5}#BZ$IS/V$IS$I_$5}$I_$I|/V$I|$JO$5}$JO$JT/V$JT$JU$5}$JU$KV/V$KV$KW$5}$KW&FU/V&FU&FV$5}&FV;'S/V;'S;=`/z<%lO/VX$;zcjWOX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$5}rs#Ejsw$5}wx#Ejx!^$5}!^!a#Ej!a#S$5}#S#T#Ej#T#q$5}#q#r$=V#r;'S$5};'S;=`$B[<%lO$5}X$=^{jW_POX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$5}rs#Ejsw$5}wx#Ejx!Q$5}!Q![$5}![!^$5}!^!a#Ej!a!c$5}!c!}$5}!}#O$5}#O#P$8y#P#S$5}#S#T#Ej#T#o$5}#o#q$5}#q#r$@T#r#y$5}#y#z$5}#z$f$5}$f$g$5}$gG|$5}G|#BY/V#BY#BZ$5}#BZ$IS/V$IS$I_$5}$I_$I|/V$I|$JO$5}$JO$JT/V$JT$JU$5}$JU$KV/V$KV$KW$5}$KW&FU/V&FU&FV$5}&FV;'S/V;'S;=`/z<%lO/VX$@YcjWOX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$5}rs#Ejsw$5}wx#Ejx!^$5}!^!a#Ej!a#S$5}#S#T#Ej#T#q$5}#q#r$Ae#r;'S$5};'S;=`$B[<%lO$5}X$AlYjW_POX/VZ[/V^p/Vqr/Vsw/Vx!^/V!a#S/V#T;'S/V;'S;=`/z<%lO/VX$B_P;=`<%l$5}!Z$Bk|jW!b`!dpOX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#=`rs#CTsv#=`vw$5}wx$$`x!Q#=`!Q![#=`![!^#=`!^!a#@c!a!c#=`!c!}#=`!}#O#=`#O#P$Bb#P#S#=`#S#T#@c#T#o#=`#o#q#=`#q#r$Ee#r#y#=`#y#z#=`#z$f#=`$f$g#=`$gG|#=`G|#BY1r#BY#BZ#=`#BZ$IS1r$IS$I_#=`$I_$I|1r$I|$JO#=`$JO$JT1r$JT$JU#=`$JU$KV1r$KV$KW#=`$KW&FU1r&FU&FV#=`&FV;'S1r;'S;=`3T<%lO1r!Z$EndjW!b`!dpOX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#=`rs#CTsv#=`vw$5}wx$$`x!^#=`!^!a#@c!a#S#=`#S#T#@c#T#q#=`#q#r$F|#r;'S#=`;'S;=`$L}<%lO#=`!Z$GX|jW!b`!dp_POX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#=`rs#CTsv#=`vw$5}wx$$`x!Q#=`!Q![#=`![!^#=`!^!a#@c!a!c#=`!c!}#=`!}#O#=`#O#P$Bb#P#S#=`#S#T#@c#T#o#=`#o#q#=`#q#r$JR#r#y#=`#y#z#=`#z$f#=`$f$g#=`$gG|#=`G|#BY1r#BY#BZ#=`#BZ$IS1r$IS$I_#=`$I_$I|1r$I|$JO#=`$JO$JT1r$JT$JU#=`$JU$KV1r$KV$KW#=`$KW&FU1r&FU&FV#=`&FV;'S1r;'S;=`3T<%lO1r!Z$J[djW!b`!dpOX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#=`rs#CTsv#=`vw$5}wx$$`x!^#=`!^!a#@c!a#S#=`#S#T#@c#T#q#=`#q#r$Kj#r;'S#=`;'S;=`$L}<%lO#=`!Z$KubjW!b`!dp_POX1rXZ-]Z[1r[^-]^p1rpq-]qr1rrs)dsv1rvw/Vwx+px!^1r!^!a-]!a#S1r#S#T-]#T;'S1r;'S;=`3T<%lO1r!Z$MQP;=`<%l#=`]$M[!RgSjWOX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$MTrs#Ejsw$MTwx#Ejx!P$MT!P!Q$5}!Q![$MT![!^$MT!^!_%!e!_!a#Ej!a!c$MT!c!}$MT!}#O$MT#O#P%.u#P#S$MT#S#T%!e#T#o$MT#o#q$MT#q#r%7e#r#s$MT#s#y$5}#y#z$5}#z$f$5}$f$g$MT$gG|$MTG|#BY6y#BY#BZ$MT#BZ$IS6y$IS$I_$MT$I_$I|6y$I|$JO$MT$JO$JT6y$JT$JU$MT$JU$KV6y$KV$KW$MT$KW&FU6y&FU&FV$MT&FV;'S6y;'S;=`9T<%l?Ah6y?Ah?BY/V?BY?Mn6y?MnO/VT%!j{gSOX#EjX^#Ej^p#Ejpq#Ejqr%!ers#Ejsw%!ewx#Ejx!P%!e!P!Q#Ej!Q![%!e![!_%!e!_!a#Ej!a!c%!e!c!}%!e!}#O%!e#O#P%%a#P#T%!e#T#o%!e#o#q%!e#q#r%,k#r#s%!e#s#y#Ej#y#z#Ej#z$f#Ej$f$g%!e$gG|%!eG|#BY8]#BY#BZ%!e#BZ$IS8]$IS$I_%!e$I_$I|8]$I|$JO%!e$JO$JT8]$JT$JU%!e$JU$KV8]$KV$KW%!e$KW&FU8]&FU&FV%!e&FV;'S8];'S;=`8}<%l?Ah8]?BY?Mn8]T%%f{gSOX#EjX^#Ej^p#Ejpq#Ejqr%!ers#Ejsw%!ewx#Ejx!P%!e!P!Q#Ej!Q![%!e![!_%!e!_!a#Ej!a!c%!e!c!}%!e!}#O%!e#O#P%%a#P#T%!e#T#o%!e#o#q%!e#q#r%(]#r#s%!e#s#y#Ej#y#z#Ej#z$f#Ej$f$g%!e$gG|%!eG|#BY8]#BY#BZ%!e#BZ$IS8]$IS$I_%!e$I_$I|8]$I|$JO%!e$JO$JT8]$JT$JU%!e$JU$KV8]$KV$KW%!e$KW&FU8]&FU&FV%!e&FV;'S8];'S;=`8}<%l?Ah8]?BY?Mn8]T%(bcgSOq#Ejqr%!ers#Ejsw%!ewx#Ejx!P%!e!P!Q#Ej!Q!_%!e!_!a#Ej!a#q%!e#q#r%)m#r#s%!e#s$f#Ej$f;'S%!e;'S;=`%.o<%l?Ah%!e?Ah?BY#Ej?BY?Mn%!e?MnO#EjT%)t{gS_POX#EjX^#Ej^p#Ejpq#Ejqr%!ers#Ejsw%!ewx#Ejx!P%!e!P!Q#Ej!Q![%!e![!_%!e!_!a#Ej!a!c%!e!c!}%!e!}#O%!e#O#P%%a#P#T%!e#T#o%!e#o#q%!e#q#r%,k#r#s%!e#s#y#Ej#y#z#Ej#z$f#Ej$f$g%!e$gG|%!eG|#BY8]#BY#BZ%!e#BZ$IS8]$IS$I_%!e$I_$I|8]$I|$JO%!e$JO$JT8]$JT$JU%!e$JU$KV8]$KV$KW%!e$KW&FU8]&FU&FV%!e&FV;'S8];'S;=`8}<%l?Ah8]?BY?Mn8]T%,pcgSOq#Ejqr%!ers#Ejsw%!ewx#Ejx!P%!e!P!Q#Ej!Q!_%!e!_!a#Ej!a#q%!e#q#r%-{#r#s%!e#s$f#Ej$f;'S%!e;'S;=`%.o<%l?Ah%!e?Ah?BY#Ej?BY?Mn%!e?MnO#EjT%.SXgS_Pqr8]sw8]x!P8]!Q!_8]!a#s8]$f;'S8];'S;=`8}<%l?Ah8]?BY?Mn8]T%.rP;=`<%l%!e]%.|!RgSjWOX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$MTrs#Ejsw$MTwx#Ejx!P$MT!P!Q$5}!Q![$MT![!^$MT!^!_%!e!_!a#Ej!a!c$MT!c!}$MT!}#O$MT#O#P%.u#P#S$MT#S#T%!e#T#o$MT#o#q$MT#q#r%2V#r#s$MT#s#y$5}#y#z$5}#z$f$5}$f$g$MT$gG|$MTG|#BY6y#BY#BZ$MT#BZ$IS6y$IS$I_$MT$I_$I|6y$I|$JO$MT$JO$JT6y$JT$JU$MT$JU$KV6y$KV$KW$MT$KW&FU6y&FU&FV$MT&FV;'S6y;'S;=`9T<%l?Ah6y?Ah?BY/V?BY?Mn6y?MnO/V]%2^kgSjWOX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$MTrs#Ejsw$MTwx#Ejx!P$MT!P!Q$5}!Q!^$MT!^!_%!e!_!a#Ej!a#S$MT#S#T%!e#T#q$MT#q#r%4R#r#s$MT#s$f$5}$f;'S$MT;'S;=`%:u<%l?Ah$MT?Ah?BY$5}?BY?Mn$MT?MnO$5}]%4[!RgSjW_POX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$MTrs#Ejsw$MTwx#Ejx!P$MT!P!Q$5}!Q![$MT![!^$MT!^!_%!e!_!a#Ej!a!c$MT!c!}$MT!}#O$MT#O#P%.u#P#S$MT#S#T%!e#T#o$MT#o#q$MT#q#r%7e#r#s$MT#s#y$5}#y#z$5}#z$f$5}$f$g$MT$gG|$MTG|#BY6y#BY#BZ$MT#BZ$IS6y$IS$I_$MT$I_$I|6y$I|$JO$MT$JO$JT6y$JT$JU$MT$JU$KV6y$KV$KW$MT$KW&FU6y&FU&FV$MT&FV;'S6y;'S;=`9T<%l?Ah6y?Ah?BY/V?BY?Mn6y?MnO/V]%7lkgSjWOX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$MTrs#Ejsw$MTwx#Ejx!P$MT!P!Q$5}!Q!^$MT!^!_%!e!_!a#Ej!a#S$MT#S#T%!e#T#q$MT#q#r%9a#r#s$MT#s$f$5}$f;'S$MT;'S;=`%:u<%l?Ah$MT?Ah?BY$5}?BY?Mn$MT?MnO$5}]%9jcgSjW_POX/VZ[/V^p/Vqr6ysw6yx!P6y!P!Q/V!Q!^6y!^!_8]!a#S6y#S#T8]#T#s6y#s$f/V$f;'S6y;'S;=`9T<%l?Ah6y?Ah?BY/V?BY?Mn6y?MnO/V]%:xP;=`<%l$MT!V%;U!OgS!b`!dpOX#@cX^#@c^p#@cpq#@cqr%:{rs#CTsv%:{vw%!ewx$$`x!P%:{!P!Q#@c!Q![%:{![!_%:{!_!a#@c!a!c%:{!c!}%:{!}#O%:{#O#P%>U#P#T%:{#T#o%:{#o#q%:{#q#r%FR#r#s%:{#s#y#@c#y#z#@c#z$f#@c$f$g%:{$gG|%:{G|#BY9Z#BY#BZ%:{#BZ$IS9Z$IS$I_%:{$I_$I|9Z$I|$JO%:{$JO$JT9Z$JT$JU%:{$JU$KV9Z$KV$KW%:{$KW&FU9Z&FU&FV%:{&FV;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V%>_!OgS!b`!dpOX#@cX^#@c^p#@cpq#@cqr%:{rs#CTsv%:{vw%!ewx$$`x!P%:{!P!Q#@c!Q![%:{![!_%:{!_!a#@c!a!c%:{!c!}%:{!}#O%:{#O#P%>U#P#T%:{#T#o%:{#o#q%:{#q#r%A_#r#s%:{#s#y#@c#y#z#@c#z$f#@c$f$g%:{$gG|%:{G|#BY9Z#BY#BZ%:{#BZ$IS9Z$IS$I_%:{$I_$I|9Z$I|$JO%:{$JO$JT9Z$JT$JU%:{$JU$KV9Z$KV$KW%:{$KW&FU9Z&FU&FV%:{&FV;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V%AhdgS!b`!dpOq#@cqr%:{rs#CTsv%:{vw%!ewx$$`x!P%:{!P!Q#@c!Q!_%:{!_!a#@c!a#q%:{#q#r%Bv#r#s%:{#s$f#@c$f;'S%:{;'S;=`%H}<%l?Ah%:{?Ah?BY#@c?BY?Mn%:{?MnO#@c!V%CR!OgS!b`!dp_POX#@cX^#@c^p#@cpq#@cqr%:{rs#CTsv%:{vw%!ewx$$`x!P%:{!P!Q#@c!Q![%:{![!_%:{!_!a#@c!a!c%:{!c!}%:{!}#O%:{#O#P%>U#P#T%:{#T#o%:{#o#q%:{#q#r%FR#r#s%:{#s#y#@c#y#z#@c#z$f#@c$f$g%:{$gG|%:{G|#BY9Z#BY#BZ%:{#BZ$IS9Z$IS$I_%:{$I_$I|9Z$I|$JO%:{$JO$JT9Z$JT$JU%:{$JU$KV9Z$KV$KW%:{$KW&FU9Z&FU&FV%:{&FV;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V%F[dgS!b`!dpOq#@cqr%:{rs#CTsv%:{vw%!ewx$$`x!P%:{!P!Q#@c!Q!_%:{!_!a#@c!a#q%:{#q#r%Gj#r#s%:{#s$f#@c$f;'S%:{;'S;=`%H}<%l?Ah%:{?Ah?BY#@c?BY?Mn%:{?MnO#@c!V%GubgS!b`!dp_POq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V%IQP;=`<%l%:{!_%I`!SgSjW!b`!dpOX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#9wrs#CTsv#9wvw$MTwx$$`x!P#9w!P!Q#=`!Q![#9w![!^#9w!^!_%:{!_!a#@c!a!c#9w!c!}#9w!}#O#9w#O#P%IT#P#S#9w#S#T%:{#T#o#9w#o#q#9w#q#r%Ll#r#s#9w#s#y#=`#y#z#=`#z$f#=`$f$g#9w$gG|#9wG|#BY@a#BY#BZ#9w#BZ$IS@a$IS$I_#9w$I_$I|@a$I|$JO#9w$JO$JT@a$JT$JU#9w$JU$KV@a$KV$KW#9w$KW&FU@a&FU&FV#9w&FV;'S@a;'S;=`B^<%l?Ah@a?Ah?BY1r?BY?Mn@a?MnO1r!_%LwlgSjW!b`!dpOX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#9wrs#CTsv#9wvw$MTwx$$`x!P#9w!P!Q#=`!Q!^#9w!^!_%:{!_!a#@c!a#S#9w#S#T%:{#T#q#9w#q#r%No#r#s#9w#s$f#=`$f;'S#9w;'S;=`&([<%l?Ah#9w?Ah?BY#=`?BY?Mn#9w?MnO#=`!_%N|!SgSjW!b`!dp_POX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#9wrs#CTsv#9wvw$MTwx$$`x!P#9w!P!Q#=`!Q![#9w![!^#9w!^!_%:{!_!a#@c!a!c#9w!c!}#9w!}#O#9w#O#P%IT#P#S#9w#S#T%:{#T#o#9w#o#q#9w#q#r&$Y#r#s#9w#s#y#=`#y#z#=`#z$f#=`$f$g#9w$gG|#9wG|#BY@a#BY#BZ#9w#BZ$IS@a$IS$I_#9w$I_$I|@a$I|$JO#9w$JO$JT@a$JT$JU#9w$JU$KV@a$KV$KW#9w$KW&FU@a&FU&FV#9w&FV;'S@a;'S;=`B^<%l?Ah@a?Ah?BY1r?BY?Mn@a?MnO1r!_&$elgSjW!b`!dpOX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#9wrs#CTsv#9wvw$MTwx$$`x!P#9w!P!Q#=`!Q!^#9w!^!_%:{!_!a#@c!a#S#9w#S#T%:{#T#q#9w#q#r&&]#r#s#9w#s$f#=`$f;'S#9w;'S;=`&([<%l?Ah#9w?Ah?BY#=`?BY?Mn#9w?MnO#=`!_&&jjgSjW!b`!dp_POX1rXZ-]Z[1r[^-]^p1rpq-]qr@ars)dsv@avw6ywx+px!P@a!P!Q1r!Q!^@a!^!_9Z!_!a-]!a#S@a#S#T9Z#T#s@a#s$f1r$f;'S@a;'S;=`B^<%l?Ah@a?Ah?BY1r?BY?Mn@a?MnO1r!_&(_P;=`<%l#9w",
  tokenizers: [scriptTokens, styleTokens, textareaTokens, tagStart, commentContent, 0, 1, 2, 3, 4, 5],
  topRules: {"Document":[0,13]},
  dialects: {noMatch: 0, selfClosing: 491},
  tokenPrec: 493
});

function getAttrs(openTag, input) {
  let attrs = Object.create(null);
  for (let att of openTag.getChildren(Attribute)) {
    let name = att.getChild(AttributeName), value = att.getChild(AttributeValue) || att.getChild(UnquotedAttributeValue);
    if (name) attrs[input.read(name.from, name.to)] =
      !value ? "" : value.type.id == AttributeValue ? input.read(value.from + 1, value.to - 1) : input.read(value.from, value.to);
  }
  return attrs
}

function findTagName(openTag, input) {
  let tagNameNode = openTag.getChild(TagName);
  return tagNameNode ? input.read(tagNameNode.from, tagNameNode.to) : " "
}

function maybeNest(node, input, tags) {
  let attrs;
  for (let tag of tags) {
    if (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(node.node.parent.firstChild, input))))
      return {parser: tag.parser}
  }
  return null
}

// tags?: {
//   tag: string,
//   attrs?: ({[attr: string]: string}) => boolean,
//   parser: Parser
// }[]
// attributes?: {
//   name: string,
//   tagName?: string,
//   parser: Parser
// }[]
 
function configureNesting(tags = [], attributes = []) {
  let script = [], style = [], textarea = [], other = [];
  for (let tag of tags) {
    let array = tag.tag == "script" ? script : tag.tag == "style" ? style : tag.tag == "textarea" ? textarea : other;
    array.push(tag);
  }
  let attrs = attributes.length ? Object.create(null) : null;
  for (let attr of attributes) (attrs[attr.name] || (attrs[attr.name] = [])).push(attr);

  return parseMixed((node, input) => {
    let id = node.type.id;
    if (id == ScriptText) return maybeNest(node, input, script)
    if (id == StyleText) return maybeNest(node, input, style)
    if (id == TextareaText) return maybeNest(node, input, textarea)

    if (id == OpenTag && other.length) {
      let n = node.node, tagName = findTagName(n, input), attrs;
      for (let tag of other) {
        if (tag.tag == tagName && (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(n, input))))) {
          let close = n.parent.lastChild;
          return {parser: tag.parser, overlay: [{from: node.to, to: close.type.id == CloseTag ? close.from : n.parent.to}]}
        }
      }
    }

    if (attrs && id == Attribute) {
      let n = node.node, nameNode;
      if (nameNode = n.firstChild) {
        let matches = attrs[input.read(nameNode.from, nameNode.to)];
        if (matches) for (let attr of matches) {
          if (attr.tagName && attr.tagName != findTagName(n.parent, input)) continue
          let value = n.lastChild;
          if (value.type.id == AttributeValue)
            return {parser: attr.parser, overlay: [{from: value.from + 1, to: value.to - 1}]}
          else if (value.type.id == UnquotedAttributeValue)
            return {parser: attr.parser, overlay: [{from: value.from, to: value.to}]}
        }
      }
    }
    return null
  })
}

const Targets = ["_blank", "_self", "_top", "_parent"];
const Charsets = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
const Methods = ["get", "post", "put", "delete"];
const Encs = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
const Bool = ["true", "false"];
const S = {}; // Empty tag spec
const Tags = {
    a: {
        attrs: {
            href: null, ping: null, type: null,
            media: null,
            target: Targets,
            hreflang: null
        }
    },
    abbr: S,
    address: S,
    area: {
        attrs: {
            alt: null, coords: null, href: null, target: null, ping: null,
            media: null, hreflang: null, type: null,
            shape: ["default", "rect", "circle", "poly"]
        }
    },
    article: S,
    aside: S,
    audio: {
        attrs: {
            src: null, mediagroup: null,
            crossorigin: ["anonymous", "use-credentials"],
            preload: ["none", "metadata", "auto"],
            autoplay: ["autoplay"],
            loop: ["loop"],
            controls: ["controls"]
        }
    },
    b: S,
    base: { attrs: { href: null, target: Targets } },
    bdi: S,
    bdo: S,
    blockquote: { attrs: { cite: null } },
    body: S,
    br: S,
    button: {
        attrs: {
            form: null, formaction: null, name: null, value: null,
            autofocus: ["autofocus"],
            disabled: ["autofocus"],
            formenctype: Encs,
            formmethod: Methods,
            formnovalidate: ["novalidate"],
            formtarget: Targets,
            type: ["submit", "reset", "button"]
        }
    },
    canvas: { attrs: { width: null, height: null } },
    caption: S,
    center: S,
    cite: S,
    code: S,
    col: { attrs: { span: null } },
    colgroup: { attrs: { span: null } },
    command: {
        attrs: {
            type: ["command", "checkbox", "radio"],
            label: null, icon: null, radiogroup: null, command: null, title: null,
            disabled: ["disabled"],
            checked: ["checked"]
        }
    },
    data: { attrs: { value: null } },
    datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
    datalist: { attrs: { data: null } },
    dd: S,
    del: { attrs: { cite: null, datetime: null } },
    details: { attrs: { open: ["open"] } },
    dfn: S,
    div: S,
    dl: S,
    dt: S,
    em: S,
    embed: { attrs: { src: null, type: null, width: null, height: null } },
    eventsource: { attrs: { src: null } },
    fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
    figcaption: S,
    figure: S,
    footer: S,
    form: {
        attrs: {
            action: null, name: null,
            "accept-charset": Charsets,
            autocomplete: ["on", "off"],
            enctype: Encs,
            method: Methods,
            novalidate: ["novalidate"],
            target: Targets
        }
    },
    h1: S, h2: S, h3: S, h4: S, h5: S, h6: S,
    head: {
        children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
    },
    header: S,
    hgroup: S,
    hr: S,
    html: {
        attrs: { manifest: null }
    },
    i: S,
    iframe: {
        attrs: {
            src: null, srcdoc: null, name: null, width: null, height: null,
            sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
            seamless: ["seamless"]
        }
    },
    img: {
        attrs: {
            alt: null, src: null, ismap: null, usemap: null, width: null, height: null,
            crossorigin: ["anonymous", "use-credentials"]
        }
    },
    input: {
        attrs: {
            alt: null, dirname: null, form: null, formaction: null,
            height: null, list: null, max: null, maxlength: null, min: null,
            name: null, pattern: null, placeholder: null, size: null, src: null,
            step: null, value: null, width: null,
            accept: ["audio/*", "video/*", "image/*"],
            autocomplete: ["on", "off"],
            autofocus: ["autofocus"],
            checked: ["checked"],
            disabled: ["disabled"],
            formenctype: Encs,
            formmethod: Methods,
            formnovalidate: ["novalidate"],
            formtarget: Targets,
            multiple: ["multiple"],
            readonly: ["readonly"],
            required: ["required"],
            type: ["hidden", "text", "search", "tel", "url", "email", "password", "datetime", "date", "month",
                "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio",
                "file", "submit", "image", "reset", "button"]
        }
    },
    ins: { attrs: { cite: null, datetime: null } },
    kbd: S,
    keygen: {
        attrs: {
            challenge: null, form: null, name: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            keytype: ["RSA"]
        }
    },
    label: { attrs: { for: null, form: null } },
    legend: S,
    li: { attrs: { value: null } },
    link: {
        attrs: {
            href: null, type: null,
            hreflang: null,
            media: null,
            sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
        }
    },
    map: { attrs: { name: null } },
    mark: S,
    menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
    meta: {
        attrs: {
            content: null,
            charset: Charsets,
            name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
            "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
        }
    },
    meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
    nav: S,
    noscript: S,
    object: {
        attrs: {
            data: null, type: null, name: null, usemap: null, form: null, width: null, height: null,
            typemustmatch: ["typemustmatch"]
        }
    },
    ol: { attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
        children: ["li", "script", "template", "ul", "ol"] },
    optgroup: { attrs: { disabled: ["disabled"], label: null } },
    option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
    output: { attrs: { for: null, form: null, name: null } },
    p: S,
    param: { attrs: { name: null, value: null } },
    pre: S,
    progress: { attrs: { value: null, max: null } },
    q: { attrs: { cite: null } },
    rp: S,
    rt: S,
    ruby: S,
    samp: S,
    script: {
        attrs: {
            type: ["text/javascript"],
            src: null,
            async: ["async"],
            defer: ["defer"],
            charset: Charsets
        }
    },
    section: S,
    select: {
        attrs: {
            form: null, name: null, size: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            multiple: ["multiple"]
        }
    },
    slot: { attrs: { name: null } },
    small: S,
    source: { attrs: { src: null, type: null, media: null } },
    span: S,
    strong: S,
    style: {
        attrs: {
            type: ["text/css"],
            media: null,
            scoped: null
        }
    },
    sub: S,
    summary: S,
    sup: S,
    table: S,
    tbody: S,
    td: { attrs: { colspan: null, rowspan: null, headers: null } },
    template: S,
    textarea: {
        attrs: {
            dirname: null, form: null, maxlength: null, name: null, placeholder: null,
            rows: null, cols: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            readonly: ["readonly"],
            required: ["required"],
            wrap: ["soft", "hard"]
        }
    },
    tfoot: S,
    th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
    thead: S,
    time: { attrs: { datetime: null } },
    title: S,
    tr: S,
    track: {
        attrs: {
            src: null, label: null, default: null,
            kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
            srclang: null
        }
    },
    ul: { children: ["li", "script", "template", "ul", "ol"] },
    var: S,
    video: {
        attrs: {
            src: null, poster: null, width: null, height: null,
            crossorigin: ["anonymous", "use-credentials"],
            preload: ["auto", "metadata", "none"],
            autoplay: ["autoplay"],
            mediagroup: ["movie"],
            muted: ["muted"],
            controls: ["controls"]
        }
    },
    wbr: S
};
const GlobalAttrs = {
    accesskey: null,
    class: null,
    contenteditable: Bool,
    contextmenu: null,
    dir: ["ltr", "rtl", "auto"],
    draggable: ["true", "false", "auto"],
    dropzone: ["copy", "move", "link", "string:", "file:"],
    hidden: ["hidden"],
    id: null,
    inert: ["inert"],
    itemid: null,
    itemprop: null,
    itemref: null,
    itemscope: ["itemscope"],
    itemtype: null,
    lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
    spellcheck: Bool,
    autocorrect: Bool,
    autocapitalize: Bool,
    style: null,
    tabindex: null,
    title: null,
    translate: ["yes", "no"],
    rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
    role: /*@__PURE__*/"alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
    "aria-activedescendant": null,
    "aria-atomic": Bool,
    "aria-autocomplete": ["inline", "list", "both", "none"],
    "aria-busy": Bool,
    "aria-checked": ["true", "false", "mixed", "undefined"],
    "aria-controls": null,
    "aria-describedby": null,
    "aria-disabled": Bool,
    "aria-dropeffect": null,
    "aria-expanded": ["true", "false", "undefined"],
    "aria-flowto": null,
    "aria-grabbed": ["true", "false", "undefined"],
    "aria-haspopup": Bool,
    "aria-hidden": Bool,
    "aria-invalid": ["true", "false", "grammar", "spelling"],
    "aria-label": null,
    "aria-labelledby": null,
    "aria-level": null,
    "aria-live": ["off", "polite", "assertive"],
    "aria-multiline": Bool,
    "aria-multiselectable": Bool,
    "aria-owns": null,
    "aria-posinset": null,
    "aria-pressed": ["true", "false", "mixed", "undefined"],
    "aria-readonly": Bool,
    "aria-relevant": null,
    "aria-required": Bool,
    "aria-selected": ["true", "false", "undefined"],
    "aria-setsize": null,
    "aria-sort": ["ascending", "descending", "none", "other"],
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuenow": null,
    "aria-valuetext": null
};
const eventAttributes = /*@__PURE__*/("beforeunload copy cut dragstart dragover dragleave dragenter dragend " +
    "drag paste focus blur change click load mousedown mouseenter mouseleave " +
    "mouseup keydown keyup resize scroll unload").split(" ").map(n => "on" + n);
for (let a of eventAttributes)
    GlobalAttrs[a] = null;
class Schema {
    constructor(extraTags, extraAttrs) {
        this.tags = Object.assign(Object.assign({}, Tags), extraTags);
        this.globalAttrs = Object.assign(Object.assign({}, GlobalAttrs), extraAttrs);
        this.allTags = Object.keys(this.tags);
        this.globalAttrNames = Object.keys(this.globalAttrs);
    }
}
Schema.default = /*@__PURE__*/new Schema;
function elementName(doc, tree, max = doc.length) {
    if (!tree)
        return "";
    let tag = tree.firstChild;
    let name = tag && tag.getChild("TagName");
    return name ? doc.sliceString(name.from, Math.min(name.to, max)) : "";
}
function findParentElement(tree, skip = false) {
    for (let cur = tree.parent; cur; cur = cur.parent)
        if (cur.name == "Element") {
            if (skip)
                skip = false;
            else
                return cur;
        }
    return null;
}
function allowedChildren(doc, tree, schema) {
    let parentInfo = schema.tags[elementName(doc, findParentElement(tree, true))];
    return (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || schema.allTags;
}
function openTags(doc, tree) {
    let open = [];
    for (let parent = tree; parent = findParentElement(parent);) {
        let tagName = elementName(doc, parent);
        if (tagName && parent.lastChild.name == "CloseTag")
            break;
        if (tagName && open.indexOf(tagName) < 0 && (tree.name == "EndTag" || tree.from >= parent.firstChild.to))
            open.push(tagName);
    }
    return open;
}
const identifier = /^[:\-\.\w\u00b7-\uffff]*$/;
function completeTag(state, schema, tree, from, to) {
    let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
    return { from, to,
        options: allowedChildren(state.doc, tree, schema).map(tagName => ({ label: tagName, type: "type" })).concat(openTags(state.doc, tree).map((tag, i) => ({ label: "/" + tag, apply: "/" + tag + end,
            type: "type", boost: 99 - i }))),
        validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function completeCloseTag(state, tree, from, to) {
    let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
    return { from, to,
        options: openTags(state.doc, tree).map((tag, i) => ({ label: tag, apply: tag + end, type: "type", boost: 99 - i })),
        validFor: identifier };
}
function completeStartTag(state, schema, tree, pos) {
    let options = [], level = 0;
    for (let tagName of allowedChildren(state.doc, tree, schema))
        options.push({ label: "<" + tagName, type: "type" });
    for (let open of openTags(state.doc, tree))
        options.push({ label: "</" + open + ">", type: "type", boost: 99 - level++ });
    return { from: pos, to: pos, options, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function completeAttrName(state, schema, tree, from, to) {
    let elt = findParentElement(tree), info = elt ? schema.tags[elementName(state.doc, elt)] : null;
    let localAttrs = info && info.attrs ? Object.keys(info.attrs) : [];
    let names = info && info.globalAttrs === false ? localAttrs
        : localAttrs.length ? localAttrs.concat(schema.globalAttrNames) : schema.globalAttrNames;
    return { from, to,
        options: names.map(attrName => ({ label: attrName, type: "property" })),
        validFor: identifier };
}
function completeAttrValue(state, schema, tree, from, to) {
    var _a;
    let nameNode = (_a = tree.parent) === null || _a === void 0 ? void 0 : _a.getChild("AttributeName");
    let options = [], token = undefined;
    if (nameNode) {
        let attrName = state.sliceDoc(nameNode.from, nameNode.to);
        let attrs = schema.globalAttrs[attrName];
        if (!attrs) {
            let elt = findParentElement(tree), info = elt ? schema.tags[elementName(state.doc, elt)] : null;
            attrs = (info === null || info === void 0 ? void 0 : info.attrs) && info.attrs[attrName];
        }
        if (attrs) {
            let base = state.sliceDoc(from, to).toLowerCase(), quoteStart = '"', quoteEnd = '"';
            if (/^['"]/.test(base)) {
                token = base[0] == '"' ? /^[^"]*$/ : /^[^']*$/;
                quoteStart = "";
                quoteEnd = state.sliceDoc(to, to + 1) == base[0] ? "" : base[0];
                base = base.slice(1);
                from++;
            }
            else {
                token = /^[^\s<>='"]*$/;
            }
            for (let value of attrs)
                options.push({ label: value, apply: quoteStart + value + quoteEnd, type: "constant" });
        }
    }
    return { from, to, options, validFor: token };
}
function htmlCompletionFor(schema, context) {
    let { state, pos } = context, around = syntaxTree(state).resolveInner(pos), tree = around.resolve(pos, -1);
    for (let scan = pos, before; around == tree && (before = tree.childBefore(scan));) {
        let last = before.lastChild;
        if (!last || !last.type.isError || last.from < last.to)
            break;
        around = tree = before;
        scan = last.from;
    }
    if (tree.name == "TagName") {
        return tree.parent && /CloseTag$/.test(tree.parent.name) ? completeCloseTag(state, tree, tree.from, pos)
            : completeTag(state, schema, tree, tree.from, pos);
    }
    else if (tree.name == "StartTag") {
        return completeTag(state, schema, tree, pos, pos);
    }
    else if (tree.name == "StartCloseTag" || tree.name == "IncompleteCloseTag") {
        return completeCloseTag(state, tree, pos, pos);
    }
    else if (context.explicit && (tree.name == "OpenTag" || tree.name == "SelfClosingTag") || tree.name == "AttributeName") {
        return completeAttrName(state, schema, tree, tree.name == "AttributeName" ? tree.from : pos, pos);
    }
    else if (tree.name == "Is" || tree.name == "AttributeValue" || tree.name == "UnquotedAttributeValue") {
        return completeAttrValue(state, schema, tree, tree.name == "Is" ? pos : tree.from, pos);
    }
    else if (context.explicit && (around.name == "Element" || around.name == "Text" || around.name == "Document")) {
        return completeStartTag(state, schema, tree, pos);
    }
    else {
        return null;
    }
}
/**
HTML tag completion. Opens and closes tags and attributes in a
context-aware way.
*/
function htmlCompletionSource(context) {
    return htmlCompletionFor(Schema.default, context);
}
/**
Create a completion source for HTML extended with additional tags
or attributes.
*/
function htmlCompletionSourceWith(config) {
    let { extraTags, extraGlobalAttributes: extraAttrs } = config;
    let schema = extraAttrs || extraTags ? new Schema(extraTags, extraAttrs) : Schema.default;
    return (context) => htmlCompletionFor(schema, context);
}

// import {parser, configureNesting} from "@lezer/html"
const defaultNesting = [
    { tag: "script",
        attrs: attrs => attrs.type == "text/typescript" || attrs.lang == "ts",
        parser: typescriptLanguage.parser },
    { tag: "script",
        attrs: attrs => attrs.type == "text/babel" || attrs.type == "text/jsx",
        parser: jsxLanguage.parser },
    { tag: "script",
        attrs: attrs => attrs.type == "text/typescript-jsx",
        parser: tsxLanguage.parser },
    { tag: "script",
        attrs(attrs) {
            return !attrs.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);
        },
        parser: javascriptLanguage.parser },
    { tag: "style",
        attrs(attrs) {
            return (!attrs.lang || attrs.lang == "css") && (!attrs.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));
        },
        parser: cssLanguage.parser }
];
const defaultAttrs = /*@__PURE__*/[
    { name: "style",
        parser: /*@__PURE__*/cssLanguage.parser.configure({ top: "Styles" }) }
].concat(/*@__PURE__*/eventAttributes.map(name => ({ name, parser: javascriptLanguage.parser })));
/**
A language provider based on the [Lezer HTML
parser](https://github.com/lezer-parser/html), extended with the
JavaScript and CSS parsers to parse the content of `<script>` and
`<style>` tags.
*/
const htmlLanguage = /*@__PURE__*/LRLanguage.define({
    name: "html",
    parser: /*@__PURE__*/parser.configure({
        props: [
            /*@__PURE__*/indentNodeProp.add({
                Element(context) {
                    let after = /^(\s*)(<\/)?/.exec(context.textAfter);
                    if (context.node.to <= context.pos + after[0].length)
                        return context.continue();
                    return context.lineIndent(context.node.from) + (after[2] ? 0 : context.unit);
                },
                "OpenTag CloseTag SelfClosingTag"(context) {
                    return context.column(context.node.from) + context.unit;
                },
                Document(context) {
                    if (context.pos + /\s*/.exec(context.textAfter)[0].length < context.node.to)
                        return context.continue();
                    let endElt = null, close;
                    for (let cur = context.node;;) {
                        let last = cur.lastChild;
                        if (!last || last.name != "Element" || last.to != cur.to)
                            break;
                        endElt = cur = last;
                    }
                    if (endElt && !((close = endElt.lastChild) && (close.name == "CloseTag" || close.name == "SelfClosingTag")))
                        return context.lineIndent(endElt.from) + context.unit;
                    return null;
                }
            }),
            /*@__PURE__*/foldNodeProp.add({
                Element(node) {
                    let first = node.firstChild, last = node.lastChild;
                    if (!first || first.name != "OpenTag")
                        return null;
                    return { from: first.to, to: last.name == "CloseTag" ? last.from : node.to };
                }
            })
        ],
        wrap: /*@__PURE__*/configureNesting(defaultNesting, defaultAttrs)
    }),
    languageData: {
        commentTokens: { block: { open: "<!--", close: "-->" } },
        indentOnInput: /^\s*<\/\w+\W$/,
        wordChars: "-._"
    }
});
/**
Language support for HTML, including
[`htmlCompletion`](https://codemirror.net/6/docs/ref/#lang-html.htmlCompletion) and JavaScript and
CSS support extensions.
*/
function html(config = {}) {
    let dialect = "", wrap;
    if (config.matchClosingTags === false)
        dialect = "noMatch";
    if (config.selfClosingTags === true)
        dialect = (dialect ? dialect + " " : "") + "selfClosing";
    if (config.nestedLanguages && config.nestedLanguages.length ||
        config.nestedAttributes && config.nestedAttributes.length)
        wrap = configureNesting((config.nestedLanguages || []).concat(defaultNesting), (config.nestedAttributes || []).concat(defaultAttrs));
    let lang = wrap || dialect ? htmlLanguage.configure({ dialect, wrap }) : htmlLanguage;
    return new LanguageSupport(lang, [
        htmlLanguage.data.of({ autocomplete: htmlCompletionSourceWith(config) }),
        config.autoCloseTags !== false ? autoCloseTags : [],
        javascript().support,
        css().support
    ]);
}
/**
Extension that will automatically insert close tags when a `>` or
`/` is typed.
*/
const autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, text) => {
    if (view.composing || view.state.readOnly || from != to || (text != ">" && text != "/") ||
        !htmlLanguage.isActiveAt(view.state, from, -1))
        return false;
    let { state } = view;
    let changes = state.changeByRange(range => {
        var _a, _b, _c;
        let { head } = range, around = syntaxTree(state).resolveInner(head, -1), name;
        if (around.name == "TagName" || around.name == "StartTag")
            around = around.parent;
        if (text == ">" && around.name == "OpenTag") {
            if (((_b = (_a = around.parent) === null || _a === void 0 ? void 0 : _a.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "CloseTag" && (name = elementName(state.doc, around.parent, head))) {
                let hasRightBracket = view.state.doc.sliceString(head, head + 1) === ">";
                let insert = `${hasRightBracket ? "" : ">"}</${name}>`;
                return { range: EditorSelection.cursor(head + 1), changes: { from: head + (hasRightBracket ? 1 : 0), insert } };
            }
        }
        else if (text == "/" && around.name == "OpenTag") {
            let empty = around.parent, base = empty === null || empty === void 0 ? void 0 : empty.parent;
            if (empty.from == head - 1 && ((_c = base.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "CloseTag" && (name = elementName(state.doc, base, head))) {
                let hasRightBracket = view.state.doc.sliceString(head, head + 1) === ">";
                let insert = `/${name}${hasRightBracket ? "" : ">"}`;
                let pos = head + insert.length + (hasRightBracket ? 1 : 0);
                return { range: EditorSelection.cursor(pos), changes: { from: head, insert } };
            }
        }
        return { range };
    });
    if (changes.changes.empty)
        return false;
    view.dispatch(changes, { userEvent: "input.type", scrollIntoView: true });
    return true;
});

export { autoCloseTags, html, htmlCompletionSource, htmlCompletionSourceWith, htmlLanguage };
