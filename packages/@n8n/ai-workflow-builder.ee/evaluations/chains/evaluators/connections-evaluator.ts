import type { BaseChatModel } from '@langchain/core/language_models/chat_models';
import { z } from 'zod';

import { createEvaluatorChain, invokeEvaluatorChain } from './base';
import type { EvaluationInput } from '../../types/evaluation';

// Schema for connections evaluation result
const connectionsResultSchema = z.object({
	score: z.number().min(0).max(1),
	violations: z.array(
		z.object({
			type: z.enum(['critical', 'major', 'minor']),
			description: z.string(),
			pointsDeducted: z.number().min(0),
		}),
	),
	analysis: z.string().describe('Brief analysis of node connections and data flow'),
});

export type ConnectionsResult = z.infer<typeof connectionsResultSchema>;

const systemPrompt = `You are an expert n8n workflow evaluator focusing specifically on NODE CONNECTIONS and DATA FLOW.
Your task is to evaluate whether nodes are properly connected with correct data flow patterns.

## Understanding n8n Connection Types

### Main vs AI Connections
n8n has two types of connections:
1. **Main connections**: Carry actual data between nodes (use "main" type)
2. **AI connections**: Provide capabilities to AI nodes (use "ai_*" types like ai_document, ai_textSplitter, ai_embedding, ai_tool, ai_languageModel, ai_memory)

### AI Capability Sub-nodes
- Document Loader, Token Splitter, Embeddings, etc. are supporting nodes
- They attach to parent nodes via ai_* connections to provide extra capabilities
- Example: Document Loader -> Vector Store [ai_document] loads documents into the store
- These sub-nodes do not require their own main connections

### Hybrid Nodes (Vector Store, Agent, Memory, etc.)
- Some nodes participate in the main execution **and** expose ai_* connectors
- Example pattern: Manual Trigger -> Vector Store (main) while Embeddings/Document Loader feed the same Vector Store via ai_*, and the Vector Store also connects to an AI Agent as a tool
- Do not penalize these hybrid nodes for having ai_* links; instead, verify they still have required main inputs/outputs when the workflow depends on them

### Valid AI Connection Patterns:
- Token Splitter -> Document Loader [ai_textSplitter]
- Document Loader -> Vector Store [ai_document]
- Embeddings -> Vector Store [ai_embedding]
- Tool nodes -> AI Agent [ai_tool]
- Vector Store -> AI Agent [ai_tool] or main when used as part of the workflow's main path

## Evaluation Criteria

### DO NOT penalize:
- AI capability sub-nodes without main connections (they rely on ai_* links)
- Hybrid nodes (Vector Store, Agent, Memory) exposing both main and ai_* connections when appropriate
- Tool nodes connected only via ai_tool connections (correct pattern)
- Empty conditional branches that are intentionally unused and clearly documented by the user

### Check for these violations:

**Critical (-40 to -50 points):**
- Disconnected main nodes that process data (not AI sub-nodes)
- Wrong execution order that breaks workflow logic
- Missing connections that would cause workflow to fail
- Circular dependencies creating infinite loops

**Major (-15 to -25 points):**
- Missing data dependencies between main nodes
- Parallel execution errors where sequential is required
- Incorrect connection types (main vs ai_*)
- Data flow that doesn't follow logical sequence

**Minor (-5 to -10 points):**
- Redundant connections
- Suboptimal routing
- Unnecessary complexity in connection patterns

## Special Cases

### Conditional Nodes (IF, Switch)
- Have multiple outputs (true/false branches, default cases)
- Default/fallback branches should usually connect somewhere, even if they just end the workflow
- Flag Switch nodes with only one connected branch unless the workflow explicitly ends or handles the missing path elsewhere
- Minor penalties are appropriate when the missing branch likely represents an unhandled scenario generated by the builder

## Scoring Instructions
1. Start with 100 points
2. Deduct points for each violation found based on severity
3. Score cannot go below 0
4. Convert to 0-1 scale by dividing by 100

Focus on whether connections enable proper data flow and workflow execution.`;

const humanTemplate = `Evaluate the connections and data flow of this workflow:

<user_prompt>
{userPrompt}
</user_prompt>

<generated_workflow>
{generatedWorkflow}
</generated_workflow>

{referenceSection}

Provide a connections evaluation with score, violations, and brief analysis.`;

export function createConnectionsEvaluatorChain(llm: BaseChatModel) {
	return createEvaluatorChain(llm, connectionsResultSchema, systemPrompt, humanTemplate);
}

export async function evaluateConnections(
	llm: BaseChatModel,
	input: EvaluationInput,
): Promise<ConnectionsResult> {
	return await invokeEvaluatorChain(createConnectionsEvaluatorChain(llm), input);
}
