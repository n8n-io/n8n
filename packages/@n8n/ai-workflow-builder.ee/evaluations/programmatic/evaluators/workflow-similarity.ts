import { execFile } from 'node:child_process';
import { writeFile, unlink } from 'node:fs/promises';
import { tmpdir } from 'node:os';
import { join } from 'node:path';
import { promisify } from 'node:util';

import type { SimpleWorkflow } from '@/types';
import type { SingleEvaluatorResult } from '@/validation/types';

const execFileAsync = promisify(execFile);

interface WorkflowSimilarityResult {
	similarity_score: number; // 0-1
	edit_cost: number;
	max_possible_cost: number;
	top_edits: Array<{
		type:
			| 'node_insert'
			| 'node_delete'
			| 'node_substitute'
			| 'edge_insert'
			| 'edge_delete'
			| 'edge_substitute';
		description: string;
		cost: number;
		priority: 'critical' | 'major' | 'minor';
		node_name?: string;
	}>;
	metadata: {
		generated_nodes: number;
		ground_truth_nodes: number;
		generated_nodes_after_filter?: number;
		ground_truth_nodes_after_filter?: number;
		config_name: string;
		config_description?: string;
	};
}

/**
 * Evaluate workflow similarity using Python graph edit distance algorithm.
 * Compares against a single reference workflow.
 *
 * @param generatedWorkflow - Workflow generated by AI
 * @param groundTruthWorkflow - Reference workflow to compare against
 * @param configPreset - Built-in preset to use ('strict' | 'standard' | 'lenient')
 * @param customConfigPath - Optional path to custom configuration file
 * @returns SingleEvaluatorResult with violations and score
 */
export async function evaluateWorkflowSimilarity(
	generatedWorkflow: SimpleWorkflow,
	groundTruthWorkflow: SimpleWorkflow,
	configPreset: 'strict' | 'standard' | 'lenient' = 'standard',
	customConfigPath?: string,
): Promise<SingleEvaluatorResult> {
	const tmpDir = tmpdir();
	const timestamp = Date.now();
	const generatedPath = join(tmpDir, `n8n-workflow-generated-${timestamp}.json`);
	const groundTruthPath = join(tmpDir, `n8n-workflow-groundtruth-${timestamp}.json`);

	let stdout = '';
	let stderr = '';

	try {
		// Write workflows to temp files
		await Promise.all([
			writeFile(generatedPath, JSON.stringify(generatedWorkflow)),
			writeFile(groundTruthPath, JSON.stringify(groundTruthWorkflow)),
		]);

		// Build command arguments
		const pythonScriptDir = join(__dirname, '..', 'python');
		const args = [
			'--from',
			pythonScriptDir,
			'python',
			'-m',
			'src.compare_workflows',
			generatedPath,
			groundTruthPath,
			'--output-format',
			'json',
		];

		// Add config argument
		if (customConfigPath) {
			args.push('--config', customConfigPath);
		} else {
			args.push('--preset', configPreset);
		}

		// Run Python script using uvx
		try {
			const result = await execFileAsync('uvx', args, {
				cwd: pythonScriptDir, // Set working directory to Python project
				timeout: 30000, // 30 second timeout
				maxBuffer: 1024 * 1024 * 10, // 10MB buffer
			});
			stdout = result.stdout;
			stderr = result.stderr;
		} catch (execError) {
			// Python script may exit with non-zero code if similarity is below threshold
			// But it still outputs valid JSON, so we should use it
			const error = execError as Error & { stdout?: string; stderr?: string; code?: number };

			stdout = error.stdout ?? '';
			stderr = error.stderr ?? '';

			// Only throw if we don't have valid output
			if (!stdout || stdout.trim() === '') {
				throw execError;
			}

			// Log the non-zero exit code but continue processing
			if (error.code) {
				console.warn(`Python script exited with code ${error.code}, but produced valid output`);
			}
		}

		// Log any warnings from Python
		if (stderr) {
			console.warn('Python workflow comparison warnings:', stderr);
		}

		// Check if stdout is empty
		if (!stdout || stdout.trim() === '') {
			throw new Error(
				`Python script produced no output. stderr: ${stderr || 'none'}. Command: uvx ${args.join(' ')}`,
			);
		}

		// Parse result
		const result = JSON.parse(stdout) as WorkflowSimilarityResult;

		// Convert Python result to SingleEvaluatorResult format
		const violations = result.top_edits.map((edit) => ({
			type: edit.priority,
			description: edit.description,
			pointsDeducted: Math.round(edit.cost),
		}));

		return {
			violations,
			score: result.similarity_score,
		};
	} catch (error) {
		// Handle specific error cases
		const caughtError = error as Error & { code?: string; killed?: boolean };

		if (caughtError.killed) {
			// Timeout error
			throw new Error(
				'Workflow comparison timed out (graphs too complex). Consider using a simpler comparison or increasing timeout.',
			);
		}

		if (caughtError.code === 'ENOENT') {
			throw new Error(
				'uvx command not found. Please install uv: https://docs.astral.sh/uv/getting-started/installation/',
			);
		}

		// Re-throw with more context
		throw new Error(`Workflow similarity evaluation failed: ${(error as Error).message}`);
	} finally {
		// Cleanup temp files (don't throw on cleanup errors)
		await Promise.allSettled([unlink(generatedPath), unlink(groundTruthPath)]);
	}
}

/**
 * Evaluate workflow similarity against multiple reference workflows.
 * Returns the result with the highest similarity score.
 *
 * @param generatedWorkflow - Workflow generated by AI
 * @param referenceWorkflows - Array of reference workflows to compare against
 * @param configPreset - Built-in preset to use ('strict' | 'standard' | 'lenient')
 * @param customConfigPath - Optional path to custom configuration file
 * @returns SingleEvaluatorResult with violations and score from the best match
 */
export async function evaluateWorkflowSimilarityMultiple(
	generatedWorkflow: SimpleWorkflow,
	referenceWorkflows: SimpleWorkflow[],
	configPreset: 'strict' | 'standard' | 'lenient' = 'standard',
	customConfigPath?: string,
): Promise<SingleEvaluatorResult> {
	if (referenceWorkflows.length === 0) {
		throw new Error('At least one reference workflow is required');
	}

	// Compare against all reference workflows in parallel
	const results = await Promise.all(
		referenceWorkflows.map((refWorkflow) =>
			evaluateWorkflowSimilarity(generatedWorkflow, refWorkflow, configPreset, customConfigPath),
		),
	);

	// Find the result with the highest similarity score
	const bestResult = results.reduce((best, current) =>
		current.score > best.score ? current : best,
	);

	return bestResult;
}
