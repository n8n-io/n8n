/**
 * Parser for generated TypeScript SDK code.
 * Takes code generated by generateWorkflowCode() and parses it back to WorkflowJSON.
 */
import { workflow as workflowFn } from './workflow-builder';

/**
 * Known n8n runtime variables that need to be escaped in template literals.
 * These are evaluated at workflow runtime, not at parse time.
 */
const N8N_RUNTIME_VARIABLES = [
	'$today',
	'$now',
	'$json',
	'$input',
	'$binary',
	'$execution',
	'$workflow',
	'$vars',
	'$node',
	'$item',
	'$position',
	'$runIndex',
	'$prevNode',
	'$env',
	'$itemIndex',
	'$parameter',
	'$jmespath',
	'$if',
	'$min',
	'$max',
];

/**
 * Escape n8n runtime variables in template literal expressions.
 * Converts ${$today} to \${$today} so they become literal strings during parsing.
 *
 * Also handles $('NodeName') function call syntax.
 */
function escapeN8nVariablesInTemplateLiterals(code: string): string {
	let result = code;

	// Escape known n8n variables: ${$today...} -> \${$today...}
	// The pattern matches ${$variableName (not preceded by a backslash)
	for (const varName of N8N_RUNTIME_VARIABLES) {
		// Build pattern to match ${$varname (e.g., ${$today, ${$json, etc.)
		// Use negative lookbehind to avoid double-escaping already escaped \${
		// Note: varName includes the $ prefix (e.g., "$today"), so we need to escape it for regex
		const escapedVarName = varName.replace(/\$/g, '\\$');
		const pattern = new RegExp('(?<!\\\\)\\$\\{' + escapedVarName, 'g');
		result = result.replace(pattern, '\\${' + varName);
	}

	// Escape $('NodeName') function calls: ${$('NodeName')...} -> \${$('NodeName')...}
	// This matches ${$( followed by anything (not preceded by backslash)
	result = result.replace(/(?<!\\)\$\{\$\(/g, '\\${$(');

	return result;
}

/**
 * Read a double-quoted string from code starting at position `start`.
 * Returns the string content and the new position after the closing quote.
 */
function readDoubleQuotedString(code: string, start: number): [string, number] {
	let result = '"';
	let i = start + 1;
	while (i < code.length) {
		if (code[i] === '\\' && i + 1 < code.length) {
			result += code[i] + code[i + 1];
			i += 2;
		} else if (code[i] === '"') {
			result += '"';
			i++;
			break;
		} else {
			result += code[i];
			i++;
		}
	}
	return [result, i];
}

/**
 * Read a template literal from code starting at position `start`.
 * Returns the content and the new position after the closing backtick.
 *
 * IMPORTANT: This also escapes template expressions inside nested template literals.
 * When we encounter \` (escaped backtick indicating start of a nested template literal),
 * all ${...} patterns until the next \` should be escaped to \${...} to prevent
 * them from being evaluated at parse time.
 *
 * Example:
 *   jsCode: `const msg = \`Hello ${name}\`;`
 * Should become:
 *   jsCode: `const msg = \`Hello \${name}\`;`
 */
function readTemplateLiteral(code: string, start: number): [string, number] {
	let result = '`';
	let i = start + 1;
	let depth = 0;
	let inNestedTemplateLiteral = false; // Track if we're inside a nested template literal

	while (i < code.length) {
		// Handle escape sequences
		if (code[i] === '\\' && i + 1 < code.length) {
			// Check if this is an escaped backtick - toggles nested template literal mode
			if (code[i + 1] === '`') {
				inNestedTemplateLiteral = !inNestedTemplateLiteral;
			}
			result += code[i] + code[i + 1];
			i += 2;
		} else if (code[i] === '$' && i + 1 < code.length && code[i + 1] === '{') {
			// Template expression found
			if (inNestedTemplateLiteral && depth === 0) {
				// We're inside a nested template literal - escape this expression
				// so it becomes a literal string instead of being evaluated
				result += '\\${';
			} else {
				result += '${';
				depth++;
			}
			i += 2;
		} else if (code[i] === '}' && depth > 0) {
			result += '}';
			i++;
			depth--;
		} else if (code[i] === '`' && depth === 0) {
			result += '`';
			i++;
			break;
		} else {
			result += code[i];
			i++;
		}
	}
	return [result, i];
}

/**
 * Read a single-quoted string from code starting at position `start`,
 * escaping any $('NodeName') patterns that would break JavaScript parsing.
 *
 * The problem: When AI generates code like `'={{ $('Node Name').item.json.field }}'`,
 * the inner single quotes in `$('Node Name')` break the outer single-quoted string.
 * JavaScript sees: `'={{ $('` as a complete string, then `Node` as an identifier (error).
 *
 * The fix: Escape the inner quotes to `$('Node Name')` -> `$(\'Node Name\')`.
 */
function readAndFixSingleQuotedString(code: string, start: number): [string, number] {
	let result = "'";
	let i = start + 1;

	while (i < code.length) {
		// Handle escape sequences
		if (code[i] === '\\' && i + 1 < code.length) {
			result += code[i] + code[i + 1];
			i += 2;
			continue;
		}

		// Check for problematic unescaped $(' pattern
		if (code[i] === '$' && code[i + 1] === '(' && code[i + 2] === "'") {
			// Found $(' - escape the opening quote and find the matching ')
			result += "$(\\'";
			i += 3;

			// Find the closing ')
			while (i < code.length) {
				if (code[i] === '\\' && i + 1 < code.length) {
					result += code[i] + code[i + 1];
					i += 2;
				} else if (code[i] === "'" && code[i + 1] === ')') {
					result += "\\')";
					i += 2;
					break;
				} else {
					result += code[i];
					i++;
				}
			}
			continue;
		}

		// Closing quote (that's not part of $('...'))
		if (code[i] === "'") {
			result += "'";
			i++;
			break;
		}

		// Regular character
		result += code[i];
		i++;
	}

	return [result, i];
}

/**
 * Escape $('NodeName') patterns inside single-quoted strings.
 *
 * This handles the case where AI-generated code contains expressions like:
 *   value: '={{ $('Lead Generation Form').item.json.fullName }}'
 *
 * Which should be:
 *   value: '={{ $(\'Lead Generation Form\').item.json.fullName }}'
 */
function escapeNodeReferencesInSingleQuotedStrings(code: string): string {
	let result = '';
	let i = 0;

	while (i < code.length) {
		// Handle double-quoted strings - copy as-is (no escaping needed)
		if (code[i] === '"') {
			const [str, newI] = readDoubleQuotedString(code, i);
			result += str;
			i = newI;
			continue;
		}

		// Handle template literals - copy as-is (no escaping needed)
		if (code[i] === '`') {
			const [str, newI] = readTemplateLiteral(code, i);
			result += str;
			i = newI;
			continue;
		}

		// Handle single-quoted strings - escape $('...') patterns
		if (code[i] === "'") {
			const [str, newI] = readAndFixSingleQuotedString(code, i);
			result += str;
			i = newI;
			continue;
		}

		// Regular character outside strings
		result += code[i];
		i++;
	}

	return result;
}

/**
 * Combined preprocessing: escape both node references in single-quoted strings
 * and n8n runtime variables in template literals.
 */
function escapeN8nVariables(code: string): string {
	// First, fix node references in single-quoted strings
	let result = escapeNodeReferencesInSingleQuotedStrings(code);
	// Then, escape n8n runtime variables in template literals
	result = escapeN8nVariablesInTemplateLiterals(result);
	return result;
}
import {
	node as nodeFn,
	trigger as triggerFn,
	sticky as stickyFn,
	placeholder as placeholderFn,
	newCredential as newCredentialFn,
	ifElse as ifElseFn,
	ifNode as ifNodeFn,
	switchCase as switchCaseFn,
} from './node-builder';
import {
	languageModel as languageModelFn,
	memory as memoryFn,
	tool as toolFn,
	outputParser as outputParserFn,
	embedding as embeddingFn,
	embeddings as embeddingsFn,
	vectorStore as vectorStoreFn,
	retriever as retrieverFn,
	documentLoader as documentLoaderFn,
	textSplitter as textSplitterFn,
	reranker as rerankerFn,
} from './subnode-builders';
import { merge as mergeFn } from './merge';
import { splitInBatches as splitInBatchesFn } from './split-in-batches';
import { nextBatch as nextBatchFn } from './next-batch';
import { fanOut as fanOutFn } from './fan-out';
import type { WorkflowJSON } from './types/base';

/**
 * Parses generated TypeScript SDK code back into WorkflowJSON.
 *
 * @param code - TypeScript code generated by generateWorkflowCode()
 * @returns The parsed workflow JSON
 *
 * @example
 * const code = generateWorkflowCode(originalJson);
 * const parsed = parseWorkflowCode(code);
 * // parsed should match originalJson
 */
export function parseWorkflowCode(code: string): WorkflowJSON {
	// Pre-process: escape n8n runtime variables in template literals
	// This prevents "$today is not defined" errors when parsing Code nodes
	const executableCode = escapeN8nVariables(code);

	// Create a function that takes our SDK functions and returns the workflow
	let factory: ReturnType<typeof Function>;
	try {
		// eslint-disable-next-line @typescript-eslint/no-implied-eval
		factory = new Function(
			'workflow',
			'node',
			'trigger',
			'sticky',
			'placeholder',
			'newCredential',
			'ifElse',
			'ifNode',
			'switchCase',
			'languageModel',
			'memory',
			'tool',
			'outputParser',
			'embedding',
			'embeddings',
			'vectorStore',
			'retriever',
			'documentLoader',
			'textSplitter',
			'reranker',
			'merge',
			'splitInBatches',
			'nextBatch',
			'fanOut',
			executableCode,
		);
	} catch (error) {
		if (error instanceof SyntaxError) {
			throw new SyntaxError(
				`Failed to parse workflow code due to syntax error: ${error.message}. ` +
					`Common causes include unclosed template literals, missing commas, or unbalanced brackets.`,
			);
		}
		throw error;
	}

	// Execute with our SDK functions (including subnode factories and composites)
	const wf = factory(
		workflowFn,
		nodeFn,
		triggerFn,
		stickyFn,
		placeholderFn,
		newCredentialFn,
		ifElseFn,
		ifNodeFn,
		switchCaseFn,
		languageModelFn,
		memoryFn,
		toolFn,
		outputParserFn,
		embeddingFn,
		embeddingsFn,
		vectorStoreFn,
		retrieverFn,
		documentLoaderFn,
		textSplitterFn,
		rerankerFn,
		mergeFn,
		splitInBatchesFn,
		nextBatchFn,
		fanOutFn,
	);

	// Return the JSON representation
	return wf.toJSON();
}

/**
 * Parses generated TypeScript SDK code and returns the WorkflowBuilder.
 * This allows callers to validate the graph structure before converting to JSON.
 *
 * @param code - TypeScript code generated by generateWorkflowCode()
 * @returns The WorkflowBuilder instance (call validate() then toJSON() on it)
 *
 * @example
 * const builder = parseWorkflowCodeToBuilder(code);
 * const validation = builder.validate();
 * if (validation.errors.length > 0) {
 *   // Handle errors
 * }
 * const workflow = builder.toJSON();
 */
export function parseWorkflowCodeToBuilder(code: string) {
	// Pre-process: escape n8n runtime variables in template literals
	const executableCode = escapeN8nVariables(code);

	// Create a function that takes our SDK functions and returns the workflow
	let factory: ReturnType<typeof Function>;
	try {
		// eslint-disable-next-line @typescript-eslint/no-implied-eval
		factory = new Function(
			'workflow',
			'node',
			'trigger',
			'sticky',
			'placeholder',
			'newCredential',
			'ifElse',
			'ifNode',
			'switchCase',
			'languageModel',
			'memory',
			'tool',
			'outputParser',
			'embedding',
			'embeddings',
			'vectorStore',
			'retriever',
			'documentLoader',
			'textSplitter',
			'reranker',
			'merge',
			'splitInBatches',
			'nextBatch',
			'fanOut',
			executableCode,
		);
	} catch (error) {
		if (error instanceof SyntaxError) {
			throw new SyntaxError(
				`Failed to parse workflow code due to syntax error: ${error.message}. ` +
					`Common causes include unclosed template literals, missing commas, or unbalanced brackets.`,
			);
		}
		throw error;
	}

	// Execute with our SDK functions and return the builder
	return factory(
		workflowFn,
		nodeFn,
		triggerFn,
		stickyFn,
		placeholderFn,
		newCredentialFn,
		ifElseFn,
		ifNodeFn,
		switchCaseFn,
		languageModelFn,
		memoryFn,
		toolFn,
		outputParserFn,
		embeddingFn,
		embeddingsFn,
		vectorStoreFn,
		retrieverFn,
		documentLoaderFn,
		textSplitterFn,
		rerankerFn,
		mergeFn,
		splitInBatchesFn,
		nextBatchFn,
		fanOutFn,
	);
}
