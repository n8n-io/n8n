/**
 * Parser for generated TypeScript SDK code.
 * Takes code generated by generateWorkflowCode() and parses it back to WorkflowJSON.
 */
import { workflow as workflowFn } from './workflow-builder';

/**
 * Known n8n runtime variables that need to be escaped in template literals.
 * These are evaluated at workflow runtime, not at parse time.
 */
const N8N_RUNTIME_VARIABLES = [
	'$today',
	'$now',
	'$json',
	'$input',
	'$binary',
	'$execution',
	'$workflow',
	'$vars',
	'$node',
	'$item',
	'$position',
	'$runIndex',
	'$prevNode',
	'$env',
	'$itemIndex',
	'$parameter',
	'$jmespath',
	'$if',
	'$min',
	'$max',
];

/**
 * Escape n8n runtime variables in template literal expressions.
 * Converts ${$today} to \${$today} so they become literal strings during parsing.
 *
 * Also handles $('NodeName') function call syntax.
 */
function escapeN8nVariables(code: string): string {
	let result = code;

	// Escape known n8n variables: ${$today...} -> \${$today...}
	// The pattern matches ${$variableName (not preceded by a backslash)
	for (const varName of N8N_RUNTIME_VARIABLES) {
		// Build pattern to match ${$varname (e.g., ${$today, ${$json, etc.)
		// Use negative lookbehind to avoid double-escaping already escaped \${
		// Note: varName includes the $ prefix (e.g., "$today"), so we need to escape it for regex
		const escapedVarName = varName.replace(/\$/g, '\\$');
		const pattern = new RegExp('(?<!\\\\)\\$\\{' + escapedVarName, 'g');
		result = result.replace(pattern, '\\${' + varName);
	}

	// Escape $('NodeName') function calls: ${$('NodeName')...} -> \${$('NodeName')...}
	// This matches ${$( followed by anything (not preceded by backslash)
	result = result.replace(/(?<!\\)\$\{\$\(/g, '\\${$(');

	return result;
}
import { node as nodeFn, trigger as triggerFn, sticky as stickyFn } from './node-builder';
import {
	languageModel as languageModelFn,
	memory as memoryFn,
	tool as toolFn,
	outputParser as outputParserFn,
	embedding as embeddingFn,
	vectorStore as vectorStoreFn,
	retriever as retrieverFn,
	documentLoader as documentLoaderFn,
	textSplitter as textSplitterFn,
} from './subnode-builders';
import { merge as mergeFn } from './merge';
import { ifBranch as ifBranchFn } from './if-branch';
import { switchCase as switchCaseFn } from './switch-case';
import { splitInBatches as splitInBatchesFn } from './split-in-batches';
import type { WorkflowJSON } from './types/base';

/**
 * Parses generated TypeScript SDK code back into WorkflowJSON.
 *
 * @param code - TypeScript code generated by generateWorkflowCode()
 * @returns The parsed workflow JSON
 *
 * @example
 * const code = generateWorkflowCode(originalJson);
 * const parsed = parseWorkflowCode(code);
 * // parsed should match originalJson
 */
export function parseWorkflowCode(code: string): WorkflowJSON {
	// Pre-process: escape n8n runtime variables in template literals
	// This prevents "$today is not defined" errors when parsing Code nodes
	const executableCode = escapeN8nVariables(code);

	// Create a function that takes our SDK functions and returns the workflow
	let factory: ReturnType<typeof Function>;
	try {
		// eslint-disable-next-line @typescript-eslint/no-implied-eval
		factory = new Function(
			'workflow',
			'node',
			'trigger',
			'sticky',
			'languageModel',
			'memory',
			'tool',
			'outputParser',
			'embedding',
			'vectorStore',
			'retriever',
			'documentLoader',
			'textSplitter',
			'merge',
			'ifBranch',
			'switchCase',
			'splitInBatches',
			executableCode,
		);
	} catch (error) {
		if (error instanceof SyntaxError) {
			throw new SyntaxError(
				`Failed to parse workflow code due to syntax error: ${error.message}. ` +
					`Common causes include unclosed template literals, missing commas, or unbalanced brackets.`,
			);
		}
		throw error;
	}

	// Execute with our SDK functions (including subnode factories and composites)
	const wf = factory(
		workflowFn,
		nodeFn,
		triggerFn,
		stickyFn,
		languageModelFn,
		memoryFn,
		toolFn,
		outputParserFn,
		embeddingFn,
		vectorStoreFn,
		retrieverFn,
		documentLoaderFn,
		textSplitterFn,
		mergeFn,
		ifBranchFn,
		switchCaseFn,
		splitInBatchesFn,
	);

	// Return the JSON representation
	return wf.toJSON();
}
