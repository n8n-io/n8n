import { splitInBatches } from '../split-in-batches';
import { workflow } from '../workflow-builder';
import { node, trigger } from '../node-builder';

describe('Split In Batches', () => {
	describe('splitInBatches()', () => {
		it('should create a split in batches builder', () => {
			const sib = splitInBatches({
				parameters: { batchSize: 10 },
			});
			expect(sib).toBeDefined();
		});

		it('should support .done() for completed processing', () => {
			const sib = splitInBatches({
				parameters: { batchSize: 10 },
			});
			const doneChain = sib.done();
			expect(doneChain).toBeDefined();
		});

		it('should support .each() for batch processing', () => {
			const sib = splitInBatches({
				parameters: { batchSize: 10 },
			});
			const eachChain = sib.each();
			expect(eachChain).toBeDefined();
		});

		it('should support explicit version', () => {
			const sib = splitInBatches({
				version: 2,
				parameters: { batchSize: 5 },
			});
			expect(sib.sibNode.version).toBe('2');
		});

		it('should default to version 3', () => {
			const sib = splitInBatches({
				parameters: { batchSize: 10 },
			});
			expect(sib.sibNode.version).toBe('3');
		});
	});

	describe('workflow integration', () => {
		it('should integrate splitInBatches with workflow builder', () => {
			const t = trigger({ type: 'n8n-nodes-base.webhookTrigger', version: 1, config: {} });
			const generateItems = node({
				type: 'n8n-nodes-base.set',
				version: 3,
				config: { name: 'Generate Items' },
			});
			const processNode = node({
				type: 'n8n-nodes-base.httpRequest',
				version: 4.2,
				config: { name: 'Process Batch' },
			});
			const finalizeNode = node({
				type: 'n8n-nodes-base.set',
				version: 3,
				config: { name: 'Finalize' },
			});

			const wf = workflow('test-id', 'Test')
				.add(t)
				.then(generateItems)
				.then(
					splitInBatches({ parameters: { batchSize: 10 } })
						.done()
						.then(finalizeNode)
						.each()
						.then(processNode)
						.loop(),
				);

			const json = wf.toJSON();

			// Should have: trigger, generateItems, splitInBatches, processNode, finalizeNode
			expect(json.nodes.length).toBeGreaterThanOrEqual(4);

			// Find split in batches node
			const sibNode = json.nodes.find((n) => n.type === 'n8n-nodes-base.splitInBatches');
			expect(sibNode).toBeDefined();
			expect(sibNode!.parameters.batchSize).toBe(10);

			// Check split in batches has two outputs
			const sibConnections = json.connections[sibNode!.name];
			expect(sibConnections).toBeDefined();
			expect(sibConnections.main).toHaveLength(2);

			// Output 0 should connect to finalize
			expect(sibConnections.main[0]).toHaveLength(1);
			expect(sibConnections.main[0][0].node).toBe('Finalize');

			// Output 1 should connect to process
			expect(sibConnections.main[1]).toHaveLength(1);
			expect(sibConnections.main[1][0].node).toBe('Process Batch');

			// Process should loop back to split in batches
			const processConnections = json.connections['Process Batch'];
			expect(processConnections).toBeDefined();
			expect(processConnections.main[0][0].node).toBe(sibNode!.name);
		});

		it('should support fan-out with array in .done().then([...]) for parallel branches', () => {
			// This pattern is generated by codegen for workflows like 6150 where
			// the "done" output of SplitInBatches fans out to multiple parallel nodes
			const t = trigger({ type: 'n8n-nodes-base.manualTrigger', version: 1, config: {} });

			const fetchSchufaNode = node({
				type: 'n8n-nodes-base.googleDrive',
				version: 1,
				config: { name: 'Fetch Schufa' },
			});

			const fetchSalaryNode = node({
				type: 'n8n-nodes-base.googleDrive',
				version: 1,
				config: { name: 'Fetch Salary' },
			});

			const generateLetterNode = node({
				type: 'n8n-nodes-base.code',
				version: 2,
				config: { name: 'Generate Cover Letter' },
			});

			// Fan-out pattern: .done().then([branch1, branch2]) where both branches lead to same node
			// This mimics: SplitInBatches -> [Fetch Schufa, Fetch Salary] -> Generate Cover Letter
			const wf = workflow('test-id', 'Test')
				.add(t)
				.then(
					splitInBatches({ name: 'Process Items', parameters: { batchSize: 1 } })
						.done()
						.then([
							fetchSchufaNode.then(generateLetterNode),
							fetchSalaryNode.then(generateLetterNode),
						]),
				);

			const json = wf.toJSON();

			// Should have: trigger, splitInBatches, fetchSchufa, fetchSalary, generateLetter
			const nodeNames = json.nodes.map((n) => n.name).sort();
			expect(nodeNames).toEqual(
				[
					'Manual Trigger',
					'Process Items',
					'Fetch Schufa',
					'Fetch Salary',
					'Generate Cover Letter',
				].sort(),
			);

			// SplitInBatches done output should connect to both fetch nodes
			const sibConnections = json.connections['Process Items'];
			expect(sibConnections).toBeDefined();
			expect(sibConnections.main[0]).toHaveLength(2);
			const doneTargets = sibConnections.main[0].map((c: { node: string }) => c.node).sort();
			expect(doneTargets).toEqual(['Fetch Salary', 'Fetch Schufa']);

			// Both fetch nodes should connect to generate letter
			const schufaConns = json.connections['Fetch Schufa'];
			expect(schufaConns).toBeDefined();
			expect(schufaConns.main[0][0].node).toBe('Generate Cover Letter');

			const salaryConns = json.connections['Fetch Salary'];
			expect(salaryConns).toBeDefined();
			expect(salaryConns.main[0][0].node).toBe('Generate Cover Letter');
		});

		it('should support fan-out with array in .each().then([...]) for parallel branches', () => {
			const t = trigger({ type: 'n8n-nodes-base.manualTrigger', version: 1, config: {} });

			const branch1Node = node({
				type: 'n8n-nodes-base.code',
				version: 2,
				config: { name: 'Branch 1' },
			});

			const branch2Node = node({
				type: 'n8n-nodes-base.code',
				version: 2,
				config: { name: 'Branch 2' },
			});

			const wf = workflow('test-id', 'Test')
				.add(t)
				.then(
					splitInBatches({ name: 'Loop', parameters: { batchSize: 1 } })
						.each()
						.then([branch1Node, branch2Node]),
				);

			const json = wf.toJSON();

			// Should have: trigger, splitInBatches, branch1, branch2
			expect(json.nodes).toHaveLength(4);

			// SplitInBatches each output (index 1) should connect to both branch nodes
			const sibConnections = json.connections['Loop'];
			expect(sibConnections).toBeDefined();
			expect(sibConnections.main[1]).toHaveLength(2);
			const eachTargets = sibConnections.main[1].map((c: { node: string }) => c.node).sort();
			expect(eachTargets).toEqual(['Branch 1', 'Branch 2']);
		});

		it('should handle splitInBatches nested in node chain (node.then(sib))', () => {
			const t = trigger({ type: 'n8n-nodes-base.webhookTrigger', version: 1, config: {} });
			const generateItems = node({
				type: 'n8n-nodes-base.set',
				version: 3,
				config: { name: 'Generate Items' },
			});
			const waitNode = node({
				type: 'n8n-nodes-base.wait',
				version: 1.1,
				config: { name: 'Wait' },
			});
			const codeNode = node({
				type: 'n8n-nodes-base.code',
				version: 2,
				config: { name: 'Code' },
			});
			const finalizeNode = node({
				type: 'n8n-nodes-base.set',
				version: 3,
				config: { name: 'Finalize' },
			});

			// Bug case: node.then(splitInBatches(...)) - nodes inside chains are lost
			const chain = t.then(generateItems).then(
				splitInBatches({ name: 'Loop', parameters: { batchSize: 5 } })
					.done()
					.then(finalizeNode)
					.each()
					.then(waitNode)
					.then(codeNode)
					.loop(),
			);

			const wf = workflow('test-id', 'Test').add(chain);
			const json = wf.toJSON();

			// Should have: trigger, generateItems, splitInBatches, waitNode, codeNode, finalizeNode
			const nodeNames = json.nodes.map((n) => n.name).sort();
			expect(nodeNames).toEqual(
				['Webhook Trigger', 'Generate Items', 'Loop', 'Wait', 'Code', 'Finalize'].sort(),
			);

			// Generate Items should connect to Loop (splitInBatches)
			const generateConnections = json.connections['Generate Items'];
			expect(generateConnections).toBeDefined();
			expect(generateConnections.main[0][0].node).toBe('Loop');

			// Loop output 0 (done) should connect to Finalize
			const loopConnections = json.connections['Loop'];
			expect(loopConnections).toBeDefined();
			expect(loopConnections.main[0][0].node).toBe('Finalize');

			// Loop output 1 (each) should connect to Wait
			expect(loopConnections.main[1][0].node).toBe('Wait');

			// Wait should connect to Code
			const waitConnections = json.connections['Wait'];
			expect(waitConnections).toBeDefined();
			expect(waitConnections.main[0][0].node).toBe('Code');

			// Code should loop back to Loop
			const codeConnections = json.connections['Code'];
			expect(codeConnections).toBeDefined();
			expect(codeConnections.main[0][0].node).toBe('Loop');
		});
	});
});
