/**
 * Type Generation Script
 *
 * Generates TypeScript types from n8n node definitions.
 *
 * This script reads node definitions from:
 * - packages/nodes-base/nodes/**\/*.ts
 * - packages/@n8n/nodes-langchain/nodes/**\/*.ts
 *
 * And generates typed interfaces with JSDoc documentation.
 *
 * Usage:
 *   npx tsx scripts/generate-types.ts
 *
 * Output:
 *   src/types/generated/index.ts
 *   src/types/generated/nodes-base.ts
 *   src/types/generated/nodes-langchain.ts
 */

import * as fs from 'fs';
import * as path from 'path';

// Configuration
const NODES_BASE_PATH = path.resolve(__dirname, '../../../../nodes-base/nodes');
const NODES_LANGCHAIN_PATH = path.resolve(__dirname, '../../../../@n8n/nodes-langchain/nodes');
const OUTPUT_PATH = path.resolve(__dirname, '../src/types/generated');

interface NodeProperty {
	name: string;
	displayName: string;
	type: string;
	description?: string;
	default?: unknown;
	required?: boolean;
	options?: Array<{ name: string; value: string | number; description?: string }>;
}

interface NodeTypeInfo {
	name: string;
	displayName: string;
	description?: string;
	version: number | number[];
	properties: NodeProperty[];
	credentials?: Array<{ name: string; required?: boolean }>;
	documentationUrl?: string;
}

/**
 * Map n8n property types to TypeScript types
 */
function mapPropertyType(prop: NodeProperty): string {
	switch (prop.type) {
		case 'string':
			return 'string';
		case 'number':
			return 'number';
		case 'boolean':
			return 'boolean';
		case 'options':
			if (prop.options && prop.options.length > 0) {
				return prop.options.map((opt) => JSON.stringify(opt.value)).join(' | ');
			}
			return 'string';
		case 'multiOptions':
			if (prop.options && prop.options.length > 0) {
				const values = prop.options.map((opt) => JSON.stringify(opt.value)).join(' | ');
				return `Array<${values}>`;
			}
			return 'string[]';
		case 'fixedCollection':
		case 'collection':
			return 'Record<string, unknown>';
		case 'json':
			return 'unknown';
		default:
			return 'unknown';
	}
}

/**
 * Generate JSDoc comment for a property
 */
function generatePropertyJSDoc(prop: NodeProperty): string[] {
	const lines: string[] = [];
	if (prop.description) {
		lines.push(`/** ${prop.description}`);
		if (prop.default !== undefined) {
			lines.push(` * @default ${JSON.stringify(prop.default)}`);
		}
		lines.push(' */');
	}
	return lines;
}

/**
 * Generate TypeScript interface for a node's parameters
 */
function generateNodeInterface(info: NodeTypeInfo): string {
	const interfaceName = `${toPascalCase(info.name)}Params`;
	const lines: string[] = [];

	// Add JSDoc for the interface
	lines.push('/**');
	lines.push(` * ${info.displayName}`);
	if (info.description) {
		lines.push(` * ${info.description}`);
	}
	if (info.documentationUrl) {
		lines.push(` * @see ${info.documentationUrl}`);
	}
	lines.push(' */');

	lines.push(`export interface ${interfaceName} {`);

	for (const prop of info.properties) {
		// Skip internal/display-only properties
		if (
			prop.type === 'notice' ||
			prop.type === 'curlImport' ||
			prop.type === 'credentials' ||
			prop.type === 'credentialsSelect'
		) {
			continue;
		}

		// Add JSDoc
		const jsdoc = generatePropertyJSDoc(prop);
		for (const line of jsdoc) {
			lines.push(`\t${line}`);
		}

		const optional = !prop.required ? '?' : '';
		const tsType = mapPropertyType(prop);
		lines.push(`\t${prop.name}${optional}: ${tsType};`);
	}

	lines.push('}');

	return lines.join('\n');
}

/**
 * Convert string to PascalCase
 */
function toPascalCase(str: string): string {
	return str
		.replace(/[-_]+/g, ' ')
		.replace(/\./g, ' ')
		.split(' ')
		.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
		.join('');
}

/**
 * Main entry point
 */
async function main() {
	console.log('Type generation script initialized.');
	console.log('');
	console.log('Note: Full type generation is a complex task that requires:');
	console.log('  1. Parsing INodeTypeDescription from compiled/source files');
	console.log('  2. Handling versioned nodes (V1, V2, etc.)');
	console.log('  3. Processing displayOptions for conditional fields');
	console.log('  4. Generating proper Expression<T> wrappers');
	console.log('');
	console.log('This is a placeholder implementation.');
	console.log('For now, the SDK works with generic parameters and runtime validation.');
	console.log('');

	// Ensure output directory exists
	if (!fs.existsSync(OUTPUT_PATH)) {
		fs.mkdirSync(OUTPUT_PATH, { recursive: true });
	}

	// Generate placeholder file
	const indexContent = `/**
 * Generated Node Types
 *
 * This file is auto-generated by scripts/generate-types.ts
 * Do not edit manually.
 *
 * To regenerate:
 *   pnpm generate-types
 */

// Placeholder - full type generation is a future enhancement
// For now, use generic parameters with the SDK

export {};
`;

	fs.writeFileSync(path.join(OUTPUT_PATH, 'index.ts'), indexContent);
	console.log(`Created ${path.join(OUTPUT_PATH, 'index.ts')}`);
}

main().catch(console.error);
