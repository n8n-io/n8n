import Decimal from 'decimal.js';
import type { ITaxNode, TaxExecutionContext } from './TaxNode';
import type { TaxData } from '../../models/TaxData';
import { TopologicalSort, type TaxConnection } from './TopologicalSort';

/**
 * Configuration settings for a tax workflow
 */
export interface WorkflowSettings {
  /** Tax year for the return (e.g., 2024) */
  taxYear: number;
  /** Taxpayer's filing status */
  filingStatus: 'single' | 'married_joint' | 'married_separate' | 'head_of_household';
  /** Taxpayer information */
  taxpayerInfo: {
    firstName: string;
    lastName: string;
    ssn: string;
  };
}

/**
 * Complete tax return data generated by workflow execution
 */
export interface TaxReturn {
  /** Unique workflow identifier */
  workflowId: string;
  /** Tax year for this return */
  taxYear: number;
  /** Filing status used for calculations */
  filingStatus: string;
  /** Taxpayer personal information */
  taxpayerInfo: any;
  /** Income breakdown and totals */
  income: {
    wages: Decimal;
    businessIncome: Decimal;
    capitalGains: Decimal;
    otherIncome: Decimal;
    totalIncome: Decimal;
  };
  /** Adjustments to income (e.g., IRA contributions, student loan interest) */
  adjustments: Array<{ type: string; amount: Decimal }>;
  /** Adjusted Gross Income */
  agi: Decimal;
  /** Deduction information */
  deductions: {
    type: 'standard' | 'itemized';
    amount: Decimal;
    itemizedBreakdown?: Record<string, Decimal>;
  };
  /** Taxable income after deductions */
  taxableIncome: Decimal;
  /** Tax calculation results */
  tax: {
    regularTax: Decimal;
    amt: Decimal;
    totalTax: Decimal;
  };
  /** Tax credits applied */
  credits: Array<{ type: string; amount: Decimal }>;
  /** Tax payments made */
  payments: Decimal;
  /** Final refund amount (positive) or amount owed (negative) */
  refundOrOwed: Decimal;
  /** Generated tax schedules */
  schedules: Map<string, any>;
  /** Generated PDF forms */
  generatedPDFs: Map<string, Uint8Array>;
}

/**
 * Tax workflow engine for executing node-based tax calculations
 *
 * The TaxWorkflow class manages a graph of tax calculation nodes and
 * executes them in topological order to produce a complete tax return.
 *
 * @example
 * ```typescript
 * const workflow = new TaxWorkflow('wf-1', 'My Tax Return', {
 *   taxYear: 2024,
 *   filingStatus: 'single',
 *   taxpayerInfo: { firstName: 'John', lastName: 'Doe', ssn: '123-45-6789' }
 * });
 *
 * workflow.addNode('input', new ManualEntryNode());
 * workflow.addNode('agi', new AGICalculatorNode());
 * workflow.addConnection({ sourceNode: 'input', sourceOutput: 0, targetNode: 'agi', targetInput: 0 });
 *
 * const taxReturn = await workflow.execute();
 * ```
 */
export class TaxWorkflow {
  /** Unique identifier for this workflow */
  id: string;

  /** Human-readable name for this workflow */
  name: string;

  /** Map of node IDs to node instances */
  nodes: Map<string, ITaxNode>;

  /** Connections between nodes defining data flow */
  connections: TaxConnection[];

  /** Workflow configuration settings */
  settings: WorkflowSettings;

  /** Internal cache of node execution outputs */
  private nodeOutputs: Map<string, TaxData[][]> = new Map();

  /**
   * Creates a new tax workflow
   *
   * @param id - Unique identifier for the workflow
   * @param name - Human-readable name for the workflow
   * @param settings - Configuration settings including tax year and filing status
   */
  constructor(
    id: string,
    name: string,
    settings: WorkflowSettings
  ) {
    this.id = id;
    this.name = name;
    this.nodes = new Map();
    this.connections = [];
    this.settings = settings;
  }

  /**
   * Adds a node to the workflow
   *
   * @param nodeId - Unique identifier for the node
   * @param node - The tax node instance to add
   */
  addNode(nodeId: string, node: ITaxNode): void {
    this.nodes.set(nodeId, node);
  }

  /**
   * Adds a connection between two nodes
   *
   * @param connection - Connection definition specifying source and target nodes
   */
  addConnection(connection: TaxConnection): void {
    this.connections.push(connection);
  }

  /**
   * Executes the workflow and generates a complete tax return
   *
   * This method:
   * 1. Sorts nodes in topological order based on connections
   * 2. Executes each node sequentially, passing outputs to connected nodes
   * 3. Builds a complete TaxReturn from the execution results
   *
   * @returns A promise that resolves to the complete tax return
   * @throws Error if workflow contains cycles or if node execution fails
   *
   * @example
   * ```typescript
   * const taxReturn = await workflow.execute();
   * console.log(`AGI: ${taxReturn.agi}`);
   * console.log(`Tax owed: ${taxReturn.refundOrOwed}`);
   * ```
   */
  async execute(): Promise<TaxReturn> {
    // Reset outputs
    this.nodeOutputs.clear();

    // Build execution context
    const context: TaxExecutionContext = {
      workflowId: this.id,
      taxYear: this.settings.taxYear,
      filingStatus: this.settings.filingStatus,
      taxpayerInfo: this.settings.taxpayerInfo,
      getNodeData: (nodeId: string) => this.nodeOutputs.get(nodeId),
    };

    // Topological sort
    const sortedNodeIds = TopologicalSort.sort(
      Array.from(this.nodes.keys()),
      this.connections
    );

    // Execute nodes in order
    for (const nodeId of sortedNodeIds) {
      const node = this.nodes.get(nodeId)!;
      const inputs = this.getNodeInputs(nodeId);
      const outputs = await node.execute(context, inputs);

      // Store outputs as array of arrays (one array per output)
      this.nodeOutputs.set(nodeId, [outputs]);
    }

    // Build TaxReturn from execution results
    return this.buildTaxReturn(context);
  }

  /**
   * Retrieves input data for a node from its connected source nodes
   *
   * @param nodeId - ID of the node to get inputs for
   * @returns Array of input data arrays, one per input connection
   * @private
   */
  private getNodeInputs(nodeId: string): TaxData[][] {
    const inputs: TaxData[][] = [];

    // Find all connections targeting this node
    const incomingConnections = this.connections.filter(
      conn => conn.targetNode === nodeId
    );

    // Sort by target input index
    incomingConnections.sort((a, b) => a.targetInput - b.targetInput);

    // Get data from source nodes
    for (const conn of incomingConnections) {
      const sourceOutputs = this.nodeOutputs.get(conn.sourceNode);
      if (sourceOutputs && sourceOutputs[conn.sourceOutput]) {
        inputs.push(sourceOutputs[conn.sourceOutput]);
      }
    }

    return inputs;
  }

  /**
   * Builds a complete TaxReturn from workflow execution results
   *
   * @param context - Execution context containing taxpayer information
   * @returns Complete tax return with all calculated values
   * @private
   */
  private buildTaxReturn(context: TaxExecutionContext): TaxReturn {
    // Find Form1040 generator output
    const form1040Node = Array.from(this.nodes.entries()).find(
      ([_, node]) => node.description.name === 'form1040Generator'
    );

    let taxReturnData: any = {};

    if (form1040Node) {
      const outputs = this.nodeOutputs.get(form1040Node[0]);
      if (outputs && outputs[0] && outputs[0][0]) {
        taxReturnData = outputs[0][0].json;
      }
    }

    return {
      workflowId: this.id,
      taxYear: context.taxYear,
      filingStatus: context.filingStatus,
      taxpayerInfo: context.taxpayerInfo,
      income: taxReturnData.income || {
        wages: new Decimal(0),
        businessIncome: new Decimal(0),
        capitalGains: new Decimal(0),
        otherIncome: new Decimal(0),
        totalIncome: new Decimal(0),
      },
      adjustments: taxReturnData.adjustments || [],
      agi: taxReturnData.agi || new Decimal(0),
      deductions: taxReturnData.deductions || {
        type: 'standard',
        amount: new Decimal(0),
      },
      taxableIncome: taxReturnData.taxableIncome || new Decimal(0),
      tax: taxReturnData.tax || {
        regularTax: new Decimal(0),
        amt: new Decimal(0),
        totalTax: new Decimal(0),
      },
      credits: taxReturnData.credits || [],
      payments: taxReturnData.payments || new Decimal(0),
      refundOrOwed: taxReturnData.refundOrOwed || new Decimal(0),
      schedules: new Map(),
      generatedPDFs: new Map(),
    };
  }
}
